diff --git a/AsicFwS1/src/main.c b/AsicFwS1/src/main.c
index 0bebaa1..7d895fc 100644
--- a/AsicFwS1/src/main.c
+++ b/AsicFwS1/src/main.c
@@ -72,6 +72,13 @@ extern void jump_to_SRAM(void);
 extern void flush_cache(unsigned long start, unsigned long size);
 extern void timestamp_start(void);
 extern unsigned int timestamp_ms(void);
+/* This block of code only used for bring up and verifying. The macro should not
+ * be enable in production code */
+#ifdef REG_DUMP_ENABLE
+	#include "std_type.h"
+	regs_fail_info_t  regs_dump[DUMP_BUFFER_MAX];
+	regs_fail_info_t* preg_dump = regs_dump;
+#endif /* REG_DUMP_ENABLE */
 /* Local function ------------------------------------------------------------*/
 /* Polynomial Used : a001 (hex) */
 
diff --git a/AsicFwS2/Makefile b/AsicFwS2/Makefile
index e5edfee..9254747 100644
--- a/AsicFwS2/Makefile
+++ b/AsicFwS2/Makefile
@@ -106,6 +106,10 @@ OBJ_ASIC_START=	${COMPILER}/armv7_start.o	\
 				${COMPILER}/reset_handler.o	\
 				${COMPILER}/startup.o		\
 
+
+ifeq ($(REG_DUMP), ENABLE)
+OBJ_APP    += ${COMPILER}/regs_dump.o
+endif
 #******************************************************************************
 #
 # The compiler to be used.
@@ -121,6 +125,7 @@ CCFLAGS+=${COMMON_CFLAGS}
 CCFLAGS+=-fno-exceptions
 AFLAGS+=-D ASIC_NUM=${ASIC_NUM} -DOS -DP2 -DDEBUG_CAM -DMIPI_SPEED_1500MHZ -DPREVIEW_TEST
 LDFLAGS+=-Wl,--start-group -lc -lgcc -lnosys -Wl,--end-group
+
 #LDFLAGS+= --specs=nano.specs --enable-newlib-nano-formatted-io
 
 BUILD_TARGET=S2_TARGET
diff --git a/AsicFwS2/include/regs_dump.h b/AsicFwS2/include/regs_dump.h
new file mode 100644
index 0000000..76ac566
--- /dev/null
+++ b/AsicFwS2/include/regs_dump.h
@@ -0,0 +1,34 @@
+/*******************************************************************************
+ * Copyright (c) 2016, The LightCo
+ * All rights reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification,are strictly prohibited without prior permission of The LightCo.
+ *
+ * @file    regs_dump.h
+ * @author  The LightCo
+ * @version V1.0.0
+ * @date    Aug 24, 2016
+ * @brief   Register dump check
+ *
+ ******************************************************************************/
+/* Define to prevent recursive inclusion ------------------------------------ */
+#ifndef ASICFWS2_INCLUDE_REGS_DUMP_H_
+#define ASICFWS2_INCLUDE_REGS_DUMP_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+/* Includes ------------------------------------------------------------------*/
+#include "FreeRTOS.h"
+/* Exported define------------------------------------------------------------*/
+/* Exported typedef  ---------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/
+
+extern void task_regs_check(void *vParameter);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ASICFWS2_INCLUDE_REGS_DUMP_H_ */
+/********** Portions COPYRIGHT 2016 Light.Co., Ltd.******* END OF FILE ********/
diff --git a/AsicFwS2/src/main.c b/AsicFwS2/src/main.c
index ec18f9f..20b74f6 100755
--- a/AsicFwS2/src/main.c
+++ b/AsicFwS2/src/main.c
@@ -19,6 +19,14 @@
 #include "rtc.h"
 #include "light_system.h"
 #include "ddr-dw.h"
+/* Public variables-----------------------------------------------------------*/
+/* This block of code only used for bring up and verifying. The macro should not
+ * be enable in production code */
+#ifdef REG_DUMP_ENABLE
+	#include "std_type.h"
+	regs_fail_info_t  regs_dump[DUMP_BUFFER_MAX];
+	regs_fail_info_t* preg_dump = regs_dump;
+#endif /* REG_DUMP_ENABLE */
 /* Private variables----------------------------------------------------------*/
 static const char __LIGHT_LCC_TEXT[] = "\tLight Control Board\r\n";
 #ifdef P2
diff --git a/AsicFwS2/src/regs_dump.c b/AsicFwS2/src/regs_dump.c
new file mode 100644
index 0000000..93509c0
--- /dev/null
+++ b/AsicFwS2/src/regs_dump.c
@@ -0,0 +1,63 @@
+/*******************************************************************************
+ * Copyright (c) 2016, The LightCo
+ * All rights reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are strictly prohibited without prior permission
+ * of The LightCo.
+ *
+ * @file    regs_dump.c
+ * @author  The LightCo
+ * @version V1.0.0
+ * @date    Aug-22-2016
+ * @brief   Dump register tasking
+ *
+ ******************************************************************************/
+/* Includes ------------------------------------------------------------------*/
+#include "board_config.h"
+#include "log.h"
+#include "queue.h"
+#include "task.h"
+#include "semphr.h"
+#include "os.h"
+#include "std_type.h"
+#include "lcc_system.h"
+
+/* Private define-------------------------------------------------------------*/
+/* Private typedef -----------------------------------------------------------*/
+/* Private macro -------------------------------------------------------------*/
+/* Private variables----------------------------------------------------------*/
+/* Exported Global variables--------------------------------------------------*/
+/* This block of code only used for bring up and verifying. The macro should not
+ * be enable in production code */
+/* Light System #light_system */
+/* Private function-----------------------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/
+
+void task_regs_check(void *vParameter)
+{
+	uint8_t exit = 0;
+	/* Start initialize #task_cam_ctrl is dependency to #lcccmd */
+	while (!exit)
+	{
+		/* #lcccmd done for slogf */
+		if(TASK_READY == task_handler[task_query_tid("slog")].state)
+			exit = 1;
+		vTaskDelay(1);
+	}
+
+	/* Task start */
+	taskENTER_CRITICAL();
+	log_msg("Start %s\r\n", __FUNCTION__);
+	taskEXIT_CRITICAL();
+
+	while (1)
+	{
+		/* Check failure query */
+		WRITE_REGS_CHECK();
+		/* Reset queried failure */
+		REGS_DUMP_RESET();
+		/* Sleep 1 second */
+		vTaskDelay(1);
+	}
+}
+/********** Portions COPYRIGHT 2016 Light.Co., Ltd.******* END OF FILE ********/
diff --git a/Makefile b/Makefile
index 0ae4ca1..3143361 100644
--- a/Makefile
+++ b/Makefile
@@ -114,6 +114,12 @@ CPU_DEF+=-ffunction-sections
 CPU_DEF+=-fdata-sections
 CPU_DEF+=-DASIC1=1 -DASIC2=2 -DASIC3=3
 
+ifeq ($(REG_DUMP), ENABLE)
+CFLAGS     += -DREG_DUMP_ENABLE
+CCFLAGS    += -DREG_DUMP_ENABLE
+AFLAGS     += -DREG_DUMP_ENABLE
+endif
+
 export CPU_DEF_C=-std=gnu99
 CPU_DEF_C+=-Wstrict-prototypes
 
diff --git a/platform/asic/hal/src/hal_com.c b/platform/asic/hal/src/hal_com.c
index c6ba268..8a6b39f 100644
--- a/platform/asic/hal/src/hal_com.c
+++ b/platform/asic/hal/src/hal_com.c
@@ -17,6 +17,7 @@
 #include "assert.h"
 #include "hal_vic.h"
 #include "hal_com.h"
+#include "std_type.h"
 
 /* Private typedef -----------------------------------------------------------*/
 /*
@@ -183,6 +184,8 @@ hal_com_return_t hal_com_sendbyte(hal_com_t *com)
 	uart_reg_t			*uart;
 	uint32_t			timeout = HAL_COM_TIMEOUT;
 	hal_com_return_t	ret;
+	__IO uint32_t* reg = NULL;
+
 
 	/* Assert input parameters */
 	assert_param(NULL_PTR != com);
@@ -202,7 +205,8 @@ hal_com_return_t hal_com_sendbyte(hal_com_t *com)
 	else
 	{
 		/* Transmit data */
-		uart->THR = (uint8_t)(*(com->data));
+		reg = &uart->THR;
+		writel(reg, (uint8_t)(*(com->data)));
 		ret = COM_OK;
 	}
 
@@ -251,7 +255,7 @@ hal_com_return_t hal_com_readbyte(hal_com_t *com)
 void hal_com_enable_irq(hal_com_t *com)
 {
 	uart_reg_t	*uart;
-
+	__IO uint32_t* reg = NULL;
 	/* Assert input parameters */
 	assert_param(NULL_PTR != com);
 	assert_param(IS_COM_PORT(com->port_name));
@@ -267,7 +271,8 @@ void hal_com_enable_irq(hal_com_t *com)
 	vic_register_irq(UART_IRQn, UART0_IRQHandler);
 	vic_set_priority_irq(UART_IRQn, 5);
 	/* Enable RX interrupt */
-	uart->IER |= COM_IER_RXNE;
+	reg = &uart->IER;
+	writel(reg, uart->IER | COM_IER_RXNE);
 }
 
 /*
@@ -277,6 +282,7 @@ void hal_com_enable_irq(hal_com_t *com)
 void hal_com_disable_irq(hal_com_t *com)
 {
 	uart_reg_t	*uart;
+	__IO uint32_t* reg = NULL;
 
 	/* Assert input parameters */
 	assert_param(NULL_PTR != com);
@@ -285,7 +291,8 @@ void hal_com_disable_irq(hal_com_t *com)
 	uart = uart_configs[com->port_name].handle;
 
 	/* Disable RX interrupt */
-	uart->IER &= (~COM_IER_RXNE);
+	reg = &uart->IER;
+	writel(reg, uart->IER & (~COM_IER_RXNE));
 	/* Clear interrupt handler */
 	uart_configs[com->port_name].data_received_handler = NULL_PTR;
 	/* Unregister interrupt handler*/
diff --git a/platform/asic/hal/src/hal_dma.c b/platform/asic/hal/src/hal_dma.c
index ad3d06b..23bd3a9 100644
--- a/platform/asic/hal/src/hal_dma.c
+++ b/platform/asic/hal/src/hal_dma.c
@@ -193,31 +193,33 @@ hal_dma_status_t hal_dma_init(dma_init_type_t *init)
 
 	uint8_t chid = init->chid;
 	uint32_t tmp;
+	__IO uint32_t* reg = NULL;
 
 	dma_channel_regs_t *dma = dma_hw[chid].ch_addr;
 	/* Set the DMA channel is used. */
 	dma_hw[chid].used = 1;
 	/* Set the DMA transfer type and flow control. */
-	dma->CFGH &= ~0x7;
-	dma->CFGH |= (init->trans_type & 0x07);
+	reg = &dma->CFGH;
+	writel(reg, dma->CFGH & ~0x7);
+	writel(reg, dma->CFGH | (init->trans_type & 0x07));
 	/* Clear the source hardware handshaking interface. */
-	dma->CFGH &= ~(0x7 << 7);
+	writel(reg, dma->CFGH & ~(0x7 << 7));
 	/* Clear the destination hardware handshaking interface. */
-	dma->CFGH &= ~(0x7 << 12);
+	writel(reg, dma->CFGH & ~(0x7 << 12));
 	/* Set the source and destination software handshaking selection. */
-	dma->CFGH |= HS_SEL_SRC | HS_SEL_DST;
+	writel(reg, dma->CFGH | HS_SEL_SRC | HS_SEL_DST);
 	switch(init->trans_type)
 	{
 
 		case MEM_TO_PER:
 			/* Set the destination hardware handshaking interface. */
-			dma->CFGH &= ~HS_SEL_DST;
-			dma->CFGH |= CFGH_DST_PER(init->periph_type);
+			writel(reg, dma->CFGH & ~HS_SEL_DST);
+			writel(reg, dma->CFGH | CFGH_DST_PER(init->periph_type));
 			break;
 		case PER_TO_MEM:
 			/* Set the source hardware handshaking interface. */
-			dma->CFGH &= ~HS_SEL_SRC;
-			dma->CFGH |= CFGH_SRC_PER(init->periph_type);
+			writel(reg, dma->CFGH & ~HS_SEL_SRC);
+			writel(reg, dma->CFGH | CFGH_SRC_PER(init->periph_type));
 			break;
 		case MEM_TO_MEM:
 		case PER_TO_PER:
@@ -225,37 +227,43 @@ hal_dma_status_t hal_dma_init(dma_init_type_t *init)
 			break;
 	}
 	/* Set the source address */
-	dma->SAR = init->src_addr;
-	dma->pad_SAR = 0;
+	reg = &dma->SAR;
+	writel(reg, init->src_addr);
+	reg = &dma->pad_SAR;
+	writel(reg, 0);
 	/* Set the destination address. */
-	dma->DAR = init->dst_addr;
-	dma->pad_DAR = 0;
+	reg = &dma->DAR;
+	writel(reg, init->dst_addr);
+	reg = &dma->pad_DAR;
+	writel(reg, 0);
 	/* Calculate the block transfer size. */
 	tmp = (init->length + ((1 << init->src_wdata) - 1)) >> init->src_wdata;
 	tmp = tmp ? tmp - 1 : 0;
-	dma->BTSR = tmp;
+	reg = &dma->BTSR;
+	writel(reg, tmp);
 	/* Set the DMA control register. */
-	dma->CRL &= ~(SRC_TR_WIDTH(0x7) | DST_TR_WIDTH(0x7) |
-					SRC_MSIZE(0xF) | DST_MSIZE(0xF));
-	dma->CRL |= (SRC_TR_WIDTH(init->src_wdata) | DST_TR_WIDTH(init->dst_wdata) |
-					SRC_MSIZE(init->src_bsize) | DST_MSIZE(init->dst_bsize));
+	reg = &dma->CRL;
+	writel(reg, dma->CRL & ~(SRC_TR_WIDTH(0x7) | DST_TR_WIDTH(0x7) |
+					SRC_MSIZE(0xF) | DST_MSIZE(0xF)));
+	writel(reg, dma->CRL | (SRC_TR_WIDTH(init->src_wdata) | DST_TR_WIDTH(init->dst_wdata) |
+					SRC_MSIZE(init->src_bsize) | DST_MSIZE(init->dst_bsize)));
 	/* Set the source master select. */
-	dma->CRL |= init->src_axi & 0x1;
+	writel(reg, dma->CRL | (init->src_axi & 0x1));
 	/* Set the destination master select. */
-	dma->CRL |= (init->dst_axi & 0x1) << 2;
+	writel(reg, dma->CRL | ((init->dst_axi & 0x1) << 2));
 	/* Clear the Source/Destination address increment. */
-	dma->CRL &= ~((BIT4) | (BIT6));
+	writel(reg, dma->CRL & ~((BIT4) | (BIT6)));
 	switch(init->trans_type)
 	{
 		case MEM_TO_PER:
 			/* Set the destination address no-increment because the device is
 			fetching data from a source peripheral FIFO with a fixed address. */
-			dma->CRL |= BIT6;
+			writel(reg, dma->CRL | BIT6);
 			break;
 		case PER_TO_MEM:
 			/* Set the source address no-increment because the device is
 			fetching data from a source peripheral FIFO with a fixed address. */
-			dma->CRL |= BIT4;
+			writel(reg, dma->CRL | BIT4);
 			break;
 		case MEM_TO_MEM:
 		case PER_TO_PER:
@@ -263,10 +271,16 @@ hal_dma_status_t hal_dma_init(dma_init_type_t *init)
 			break;
 	}
 	/* Set the interrupt enable/signal register. */
-	dma->INTSER |= (DMA_TRANSFER_DONE | SHADOWREG_OR_LLI_INVALID_ERR |
-					SLVIF_MULTIBLKTYPE_ERR | CH_ABORTED);
-	dma->INTSIER |= (DMA_TRANSFER_DONE | SHADOWREG_OR_LLI_INVALID_ERR |
-					SLVIF_MULTIBLKTYPE_ERR | CH_ABORTED);
+	reg = &dma->INTSER;
+	writel(reg, dma->INTSER | (DMA_TRANSFER_DONE |
+			                   SHADOWREG_OR_LLI_INVALID_ERR |
+					           SLVIF_MULTIBLKTYPE_ERR |
+					           CH_ABORTED));
+	reg = &dma->INTSIER;
+	writel(reg, dma->INTSIER | (DMA_TRANSFER_DONE |
+			                    SHADOWREG_OR_LLI_INVALID_ERR |
+					            SLVIF_MULTIBLKTYPE_ERR |
+					            CH_ABORTED));
 	/* Initialize the call back function if it is used. */
 	if(init->clb_func)
 		dma_hw[chid].clb_handler = init->clb_func;
@@ -291,34 +305,48 @@ hal_dma_status_t hal_dma_init(dma_init_type_t *init)
 		}
 		for(int i = 0; i < block_cnt ; i++)
 		{
-			dma_hw[chid].lli[i].SAR = init->lli[i].src_addr;
-			dma_hw[chid].lli[i].pad_SAR = 0;
-			dma_hw[chid].lli[i].DAR = init->lli[i].dst_addr;
-			dma_hw[chid].lli[i].pad_DAR = 0;
+			reg = &dma_hw[chid].lli[i].SAR;
+			writel(reg, init->lli[i].src_addr);
+			reg = &dma_hw[chid].lli[i].pad_SAR;
+			writel(reg, 0);
+			reg = &dma_hw[chid].lli[i].DAR;
+			writel(reg, init->lli[i].dst_addr);
+			reg = &dma_hw[chid].lli[i].pad_DAR;
+			writel(reg, 0);
 			tmp = (init->lli[i].length >> init->src_wdata);
 			tmp = tmp ? tmp - 1 : 0;
-			dma_hw[chid].lli[i].BTSR = tmp;
-			dma_hw[chid].lli[i].CRH = dma->CRH;
-			dma_hw[chid].lli[i].CRH &= ~SHADOWREG_OR_LLI_LAST;
-			dma_hw[chid].lli[i].CRH |= SHADOWREG_OR_LLI_VALID;
-			dma_hw[chid].lli[i].CRL = dma->CRL;
+			reg = &dma_hw[chid].lli[i].BTSR;
+			writel(reg, tmp);
+			reg = &dma_hw[chid].lli[i].CRH;
+			writel(reg, dma->CRH);
+			reg = &dma_hw[chid].lli[i].CRH;
+			writel(reg, dma_hw[chid].lli[i].CRH & ~SHADOWREG_OR_LLI_LAST);
+			reg = &dma_hw[chid].lli[i].CRH;
+			writel(reg, dma_hw[chid].lli[i].CRH | SHADOWREG_OR_LLI_VALID);
+			reg = &dma_hw[chid].lli[i].CRL;
+			writel(reg, dma->CRL);
 
 			/* The last LLi. */
 			if(i == (block_cnt - 1))
 			{
-				dma_hw[chid].lli[i].LLPR = (uint32_t)&(dma_hw[chid].lli[0]);
-				dma_hw[chid].lli[i].CRH |= SHADOWREG_OR_LLI_LAST;
+				reg = &dma_hw[chid].lli[i].LLPR;
+				writel(reg, (uint32_t)&(dma_hw[chid].lli[0]));
+				reg = &dma_hw[chid].lli[i].CRH;
+				writel(reg, dma_hw[chid].lli[i].CRH | SHADOWREG_OR_LLI_LAST);
 			}
 			else
 			{
-				dma_hw[chid].lli[i].LLPR = (uint32_t)&(dma_hw[chid].lli[i+1]);
+				reg = &dma_hw[chid].lli[i].LLPR;
+				writel(reg, (uint32_t)&(dma_hw[chid].lli[i+1]));
 			}
 		}
 		flush_cache((unsigned long)dma_hw[chid].lli,
 											sizeof(dma_lli_regs_t) * block_cnt);
-		dma->LLP = (uint32_t)dma_hw[chid].lli;
-		dma->CFGL |= CFG_SRC_MB_TYPE(LINKED_LIST) |
-						CFG_DST_MB_TYPE(LINKED_LIST);
+		reg = &dma->LLP;
+		writel(reg, (uint32_t)dma_hw[chid].lli);
+		reg = &dma->LLP;
+		writel(reg, dma->CFGL | CFG_SRC_MB_TYPE(LINKED_LIST) |
+						        CFG_DST_MB_TYPE(LINKED_LIST));
 	}
 	else
 	{
@@ -343,36 +371,47 @@ hal_dma_status_t hal_dma_init(dma_init_type_t *init)
 			}
 			for(int i = 0; i < block_cnt ; i++)
 			{
-				dma_hw[chid].lli[i].SAR = init->src_addr + i * MAX_DMA_BLOCK_TS;
-				dma_hw[chid].lli[i].pad_SAR = 0;
-				dma_hw[chid].lli[i].DAR = init->dst_addr + i * MAX_DMA_BLOCK_TS;
-				dma_hw[chid].lli[i].pad_DAR = 0;
-
-				dma_hw[chid].lli[i].CRH = dma->CRH;
-				dma_hw[chid].lli[i].CRH |= SHADOWREG_OR_LLI_VALID;
-				dma_hw[chid].lli[i].CRL = dma->CRL;
+				reg = &dma_hw[chid].lli[i].SAR;
+				writel(reg, init->src_addr + i * MAX_DMA_BLOCK_TS);
+				reg = &dma_hw[chid].lli[i].pad_SAR;
+				writel(reg, 0);
+				reg = &dma_hw[chid].lli[i].DAR;
+				writel(reg, init->dst_addr + i * MAX_DMA_BLOCK_TS);
+				reg = &dma_hw[chid].lli[i].pad_DAR;
+				writel(reg, 0);
+				reg = &dma_hw[chid].lli[i].CRH;
+				writel(reg, dma->CRH);
+				reg = &dma_hw[chid].lli[i].CRH;
+				writel(reg, dma_hw[chid].lli[i].CRH | SHADOWREG_OR_LLI_VALID);
+				reg = &dma_hw[chid].lli[i].CRL;
+				writel(reg, dma->CRL);
 				/* The last LLi. */
 				if(i == block_cnt - 1)
 				{
-					dma_hw[chid].lli[i].BTSR =
+					reg = &dma_hw[chid].lli[i].BTSR;
+					writel(reg,
 					(
 						(init->length - (((MAX_DMA_BLOCK_TS * (block_cnt - 1))
 						<< init->src_wdata) >> init->src_wdata)) - 1
-					);
-					dma_hw[chid].lli[i].CRH |= SHADOWREG_OR_LLI_LAST;
+					));
+					reg = &dma_hw[chid].lli[i].CRH;
+					writel(reg, dma_hw[chid].lli[i].CRH | SHADOWREG_OR_LLI_LAST);
 				}
 				else
 				{
-					dma_hw[chid].lli[i].BTSR = MAX_DMA_BLOCK_TS - 1;
-					dma_hw[chid].lli[i].LLPR =
-											(uint32_t)&(dma_hw[chid].lli[i+1]);
+					reg = &dma_hw[chid].lli[i].BTSR;
+					writel(reg, MAX_DMA_BLOCK_TS - 1);
+					reg = &dma_hw[chid].lli[i].LLPR;
+					writel(reg, (uint32_t)&(dma_hw[chid].lli[i+1]));
 				}
 			}
 			flush_cache((unsigned long)dma_hw[chid].lli,
 											sizeof(dma_lli_regs_t)*block_cnt);
-			dma->LLP = (uint32_t)dma_hw[chid].lli;
-			dma->CFGL |= CFG_SRC_MB_TYPE(LINKED_LIST) |
-						CFG_DST_MB_TYPE(LINKED_LIST);
+			reg = &dma->LLP;
+			writel(reg, (uint32_t)dma_hw[chid].lli);
+			reg = &dma->CFGL;
+			writel(reg, dma->CFGL | CFG_SRC_MB_TYPE(LINKED_LIST) |
+						            CFG_DST_MB_TYPE(LINKED_LIST));
 		}
 	}
 	return HAL_DMA_OK;
@@ -395,10 +434,13 @@ hal_dma_status_t hal_dma_channel_enable(hal_dma_channel_t chid)
 		return HAL_DMA_CH_INVALID;
 	}
 	dma_channel_regs_t *dma = dma_hw[chid].ch_addr;
+	__IO uint32_t* reg = NULL;
 	/* Clear the clear interrupt register. */
-	dma->INTCLR = 0xFFFFFFFF;
+	reg = &dma->CFGL;
+	writel(reg, 0xFFFFFFFF);
 	/* Enable the DMA channel register. */
-	dma_base->CHER |= 0x101 << chid;
+	reg = &dma_base->CHER;
+	writel(reg, dma_base->CHER | 0x101 << chid);
 	return HAL_DMA_OK;
 }
 hal_dma_status_t hal_dma_channel_disable(hal_dma_channel_t chid)
@@ -408,10 +450,13 @@ hal_dma_status_t hal_dma_channel_disable(hal_dma_channel_t chid)
 		return HAL_DMA_CH_INVALID;
 	}
 	dma_channel_regs_t *dma = dma_hw[chid].ch_addr;
+	__IO uint32_t* reg = NULL;
 	/* Clear the clear interrupt register. */
-	dma->INTCLR = 0xFFFFFFFF;
+	reg = &dma->INTCLR;
+	writel(reg, 0xFFFFFFFF);
 	/* Enable the DMA channel register. */
-	dma_base->CHER &= ~(0x101 << chid);
+	reg = &dma_base->CHER;
+	writel(reg, dma_base->CHER & ~(0x101 << chid));
 	return HAL_DMA_OK;
 }
 hal_dma_status_t hal_dma_set_channel_priority(hal_dma_channel_t chid,
@@ -422,8 +467,11 @@ hal_dma_status_t hal_dma_set_channel_priority(hal_dma_channel_t chid,
 		return HAL_DMA_CH_INVALID;
 	}
 	dma_channel_regs_t *dma = dma_hw[chid].ch_addr;
-	dma->CFGH &= ~(0x7 << 17);
-	dma->CFGH |= priority << 17;
+	__IO uint32_t* reg = NULL;
+
+	reg = &dma->CFGH;
+	writel(reg, dma->CFGH & ~(0x7 << 17));
+	writel(reg, dma->CFGH | priority << 17);
 	return HAL_DMA_OK;
 }
 uint8_t hal_dma_get_channel_priority(hal_dma_channel_t chid)
@@ -454,16 +502,21 @@ hal_dma_status_t hal_dma_is_transfer_completed(hal_dma_channel_t chid)
 }
 void hal_dma_reset(void)
 {
-	dma_base->RR = 0x1;
+	__IO uint32_t* reg = NULL;
+
+	reg = &dma_base->RR;
+	writel(reg, 0x1);
 	while(dma_base->RR & 0x1);
 }
 void hal_dma_enable_global_interrupt(uint8_t irq_priority)
 {
+	__IO uint32_t* reg = NULL;
 	/* Is the DMA interrupt flag initialized. */
 	if(!dma_init_irq_flag)
 	{
 		/* Enable the DMA global interrupt. */
-		dma_base->CFGR = 0x03;
+		reg = &dma_base->CFGR;
+		writel(reg, 0x03);
 		/* Register the interrupt line for the DMA controller. */
 		vic_register_irq(DMA_IRQn, dma_irq_handler);
 		/* Set the priority of the DMA interrupt. */
@@ -474,11 +527,14 @@ void hal_dma_enable_global_interrupt(uint8_t irq_priority)
 static void dma_irq_handler(void)
 {
 	register uint32_t common_int = 0;
+	__IO uint32_t* reg = NULL;
+
 	common_int = dma_base->INTCHSR;
 	if(common_int & INT_COMMOM)
 	{
 		/* Clear the interrupt register. */
-		dma_base->INTCLR = 0xFFFFFFFF;
+		reg = &dma_base->INTCLR;
+		writel(reg, 0xFFFFFFFF);
 	}
 	for(int i = 0; i < HAL_DMA_CH_MAX; i++)
 	{
@@ -493,7 +549,8 @@ static void dma_irq_handler(void)
 				}
 			}
 			/* Clear all bits of the channel interrupt register. */
-			dma_hw[i].ch_addr->INTCLR = 0xFFFFFFFF;
+			reg = &dma_hw[i].ch_addr->INTCLR;
+			writel(reg, 0xFFFFFFFF);
 		}
 	}
 }
diff --git a/platform/asic/hal/src/hal_gpio.c b/platform/asic/hal/src/hal_gpio.c
index 6353df2..4a1059c 100644
--- a/platform/asic/hal/src/hal_gpio.c
+++ b/platform/asic/hal/src/hal_gpio.c
@@ -18,6 +18,7 @@
 #include "cortex_r4.h"
 #include "assert.h"
 #include "hal_vic.h"
+#include "std_type.h"
 
 /* Private define ------------------------------------------------------------*/
 
@@ -131,7 +132,6 @@ void hal_gpio_init(hal_gpio_t *gpio)
 {
 	hal_gpio_reg_t	*gpio_reg = GPIO;
 	__IO uint32_t	*dir_reg;
-
 	/* Assert parameters */
 	assert_param(NULL_PTR != gpio);
 	assert_param(IS_GPIO_PORT(gpio->port));
@@ -139,7 +139,7 @@ void hal_gpio_init(hal_gpio_t *gpio)
 	assert_param(IS_GPIO_DIR(gpio->direction));
 
 	/* Hard code to set GPIO normal mode */
-	// *((__IO uint32_t *)0x020000A8) = 0x00FE0000;
+	*((__IO uint32_t *)0x020000A8) |= 0x00000600;
 
 	/* Get pointer to the direction register of the corresponding port */
 	if (GPIO_PORTA == gpio->port)
@@ -153,9 +153,13 @@ void hal_gpio_init(hal_gpio_t *gpio)
 
 	/* Set direction */
 	if(GPIO_DIR_IN == gpio->direction)
-		*dir_reg &= (~(0x01 << gpio->pin));
+	{
+		writel(dir_reg, *dir_reg & (~(0x01 << gpio->pin)));
+	}
 	else
-		*dir_reg |= (gpio->direction << gpio->pin);
+	{
+		writel(dir_reg, *dir_reg | (gpio->direction << gpio->pin));
+	}
 }
 
 /*
@@ -165,7 +169,7 @@ void hal_gpio_init(hal_gpio_t *gpio)
 void hal_gpio_set_low(hal_gpio_t *gpio)
 {
 	hal_gpio_reg_t	*gpio_reg = GPIO;
-
+	__IO uint32_t* reg = NULL;
 	/* Assert parameters */
 	assert_param(NULL_PTR != gpio);
 	assert_param(IS_GPIO_PORT(gpio->port));
@@ -173,13 +177,25 @@ void hal_gpio_set_low(hal_gpio_t *gpio)
 	assert_param(GPIO_DIR_OUT == gpio->direction);
 
 	if(GPIO_PORTA == gpio->port)
-		gpio_reg->DRA &= (~(0x01 << gpio->pin));
+	{
+		reg = &gpio_reg->DRA;
+		writel(reg, gpio_reg->DRA & (~(0x01 << gpio->pin)));
+	}
 	else if(GPIO_PORTB == gpio->port)
-		gpio_reg->DRB &= (~(0x01 << gpio->pin));
+	{
+		reg = &gpio_reg->DRB;
+		writel(reg, gpio_reg->DRB & (~(0x01 << gpio->pin)));
+	}
 	else if(GPIO_PORTC == gpio->port)
-		gpio_reg->DRC &= (~(0x01 << gpio->pin));
+	{
+		reg = &gpio_reg->DRC;
+		writel(reg, gpio_reg->DRC & (~(0x01 << gpio->pin)));
+	}
 	else /* GPIO_PORTD */
-		gpio_reg->DRD &= (~(0x01 << gpio->pin));
+	{
+		reg = &gpio_reg->DRD;
+		writel(reg, gpio_reg->DRD & (~(0x01 << gpio->pin)));
+	}
 }
 
 /*
@@ -189,6 +205,7 @@ void hal_gpio_set_low(hal_gpio_t *gpio)
 void hal_gpio_set_high(hal_gpio_t *gpio)
 {
 	hal_gpio_reg_t	*gpio_reg = GPIO;
+	__IO uint32_t* reg = NULL;
 
 	/* Assert parameters */
 	assert_param(NULL_PTR != gpio);
@@ -197,13 +214,25 @@ void hal_gpio_set_high(hal_gpio_t *gpio)
 	assert_param(GPIO_DIR_OUT == gpio->direction);
 
 	if(GPIO_PORTA == gpio->port)
-		gpio_reg->DRA |= (0x01 << gpio->pin);
+	{
+		reg = &gpio_reg->DRA;
+		writel(reg, gpio_reg->DRA | (0x01 << gpio->pin));
+	}
 	else if(GPIO_PORTB == gpio->port)
-		gpio_reg->DRB |= (0x01 << gpio->pin);
+	{
+		reg = &gpio_reg->DRB;
+		writel(reg, gpio_reg->DRB | (0x01 << gpio->pin));
+	}
 	else if(GPIO_PORTC == gpio->port)
-		gpio_reg->DRC |= (0x01 << gpio->pin);
+	{
+		reg = &gpio_reg->DRC;
+		writel(reg, gpio_reg->DRC | (0x01 << gpio->pin));
+	}
 	else /* GPIO_PORTD */
-		gpio_reg->DRD |= (0x01 << gpio->pin);
+	{
+		reg = &gpio_reg->DRD;
+		writel(reg, gpio_reg->DRD | (0x01 << gpio->pin));
+	}
 }
 
 /*
@@ -213,6 +242,7 @@ void hal_gpio_set_high(hal_gpio_t *gpio)
 void hal_gpio_toggle(hal_gpio_t *gpio)
 {
 	hal_gpio_reg_t	*gpio_reg = GPIO;
+	__IO uint32_t* reg = NULL;
 
 	/* Assert parameters */
 	assert_param(NULL_PTR != gpio);
@@ -221,13 +251,25 @@ void hal_gpio_toggle(hal_gpio_t *gpio)
 	assert_param(GPIO_DIR_OUT == gpio->direction);
 
 	if(GPIO_PORTA == gpio->port)
-		gpio_reg->DRA ^= (0x01 << gpio->pin);
+	{
+		reg = &gpio_reg->DRA;
+		writel(reg, gpio_reg->DRA ^ (0x01 << gpio->pin));
+	}
 	else if(GPIO_PORTB == gpio->port)
-		gpio_reg->DRB ^= (0x01 << gpio->pin);
+	{
+		reg = &gpio_reg->DRB;
+		writel(reg, gpio_reg->DRB ^ (0x01 << gpio->pin));
+	}
 	else if(GPIO_PORTC == gpio->port)
-		gpio_reg->DRC ^= (0x01 << gpio->pin);
+	{
+		reg = &gpio_reg->DRC;
+		writel(reg, gpio_reg->DRC ^ (0x01 << gpio->pin));
+	}
 	else /* GPIO_PORTD */
-		gpio_reg->DRD ^= (0x01 << gpio->pin);
+	{
+		reg = &gpio_reg->DRD;
+		writel(reg, gpio_reg->DRD ^ (0x01 << gpio->pin));
+	}
 }
 
 /*
@@ -285,7 +327,7 @@ void hal_gpio_enable_exti(hal_gpio_exti_t *exti)
 {
 	hal_gpio_reg_t	*gpio_reg = GPIO;
 	uint32_t		pin_mask;
-
+	__IO uint32_t* reg = NULL;
 	/* Assert parameters */
 	assert_param(NULL_PTR != exti);
 	assert_param(IS_GPIO_PIN(exti->pin));
@@ -298,26 +340,32 @@ void hal_gpio_enable_exti(hal_gpio_exti_t *exti)
 	if (GPIO_EXTI_FALLING_EDGE == exti->int_type)
 	{
 		/* Select edge-sensitive */
-		gpio_reg->INTTYPLEVL |= pin_mask;
+		reg = &gpio_reg->INTTYPLEVL;
+		writel(reg, gpio_reg->INTTYPLEVL | pin_mask);
 		/* Select active-low polarity */
-		gpio_reg->INTPOL &= (~pin_mask);
+		reg = &gpio_reg->INTPOL;
+		writel(reg, gpio_reg->INTPOL & (~pin_mask));
 	}
 	else /* GPIO_EXTI_RISING_EDGE */
 	{
 		/* Select edge-sensitive */
-		gpio_reg->INTTYPLEVL |= pin_mask;
+		reg = &gpio_reg->INTTYPLEVL;
+		writel(reg, gpio_reg->INTTYPLEVL | pin_mask);
 		/* Select active-high polarity */
-		gpio_reg->INTPOL |= pin_mask;
+		reg = &gpio_reg->INTPOL;
+		writel(reg, gpio_reg->INTPOL | pin_mask);
 	}
 	/* Synchronize with pclk_intr */
-	gpio_reg->LSSYNC |= pin_mask;
+	reg = &gpio_reg->LSSYNC;
+	writel(reg, gpio_reg->LSSYNC | pin_mask);
 	/* Set interrupt handler */
 	exti_configs[exti->pin].irq_handler = exti->irq_handler;
 	exti_configs[exti->pin].enabled = TRUE;
 	/* Register interrupt handler */
 	vic_register_irq(GPIO_IRQn, EXTI_IRQHandler);
 	/* Enable external interrupt */
-	gpio_reg->INTEN |= pin_mask;
+	reg = &gpio_reg->INTEN;
+	writel(reg, gpio_reg->INTEN | pin_mask);
 }
 
 /*
@@ -328,13 +376,15 @@ void hal_gpio_disable_exti(hal_gpio_exti_t *exti)
 {
 	hal_gpio_reg_t	*gpio_reg = GPIO;
 	uint8_t			i;
+	__IO uint32_t* reg = NULL;
 
 	/* Assert parameters */
 	assert_param(NULL_PTR != exti);
 	assert_param(IS_GPIO_PIN(exti->pin));
 
 	/* Disable external interrupt */
-	gpio_reg->INTEN &= (~(0x01 << exti->pin));
+	reg = &gpio_reg->INTEN;
+	writel(reg, gpio_reg->INTEN & (~(0x01 << exti->pin)));
 	/* Clear interrupt handler */
 	exti_configs[exti->pin].irq_handler = NULL_PTR;
 	exti_configs[exti->pin].enabled = FALSE;
@@ -355,6 +405,7 @@ static void EXTI_IRQHandler(void)
 	hal_gpio_reg_t	*gpio_reg = GPIO;
 	int				interrupt_pin = GPIO_PIN_MAX_IDX;
 	int				i;
+	__IO uint32_t* reg = NULL;
 
 	/* Get the interrupt source */
 	for(i = 0; i < GPIO_PIN_MAX_IDX; i++)
@@ -370,7 +421,8 @@ static void EXTI_IRQHandler(void)
 	if(GPIO_PIN_MAX_IDX > interrupt_pin)
 	{
 		/* Clear interrupt pending */
-		gpio_reg->EOI |= (0x01 << interrupt_pin);
+		reg = &gpio_reg->EOI;
+		writel(reg, gpio_reg->EOI | (0x01 << interrupt_pin));
 
 		if(NULL_PTR != exti_configs[interrupt_pin].irq_handler)
 		{
diff --git a/platform/asic/hal/src/hal_i2c.c b/platform/asic/hal/src/hal_i2c.c
index 6360def..ab41f69 100644
--- a/platform/asic/hal/src/hal_i2c.c
+++ b/platform/asic/hal/src/hal_i2c.c
@@ -317,7 +317,7 @@ void hal_i2c_init(hal_i2c_t *i2c)
 	i2c_config_t	*i2c_config;
 	i2c_reg_t		*i2c_reg;
 	uint32_t			input_clock_khz;
-
+	__IO uint32_t* reg = NULL;
 	/* Assert input parameters */
 	assert_param(NULL != i2c);
 	assert_param(IS_I2C_CHANNEL(i2c->chid));
@@ -335,39 +335,46 @@ void hal_i2c_init(hal_i2c_t *i2c)
 	i2c_reg = i2c_config->i2c_base;
 
 	/* Disable the selected i2c channel */
-	i2c_reg->EN = 0;
+	reg = &i2c_reg->EN;
+	writel(reg, 0x00);
 
+	reg = &i2c_reg->CON;
 	/* Set operation mode */
 	if (I2C_MASTER == i2c->operation_mode)
 	{
 		/* Enable master mode */
-		i2c_reg->CON |= I2C_CON_MASTER_MODE_MASK;
+		writel(reg, i2c_reg->CON | I2C_CON_MASTER_MODE_MASK);
 		/* Disable slave mode */
-		i2c_reg->CON |= I2C_CON_SLAVE_DISABLE_MASK;
+		writel(reg, i2c_reg->CON | I2C_CON_SLAVE_DISABLE_MASK);
 	}
 	else
 	{
 		/* Enable slave mode */
-		i2c_reg->CON &= (~I2C_CON_SLAVE_DISABLE_MASK);
+		writel(reg, i2c_reg->CON & (~I2C_CON_SLAVE_DISABLE_MASK));
 		/* Disable master mode */
-		i2c_reg->CON &= (~I2C_CON_MASTER_MODE_MASK);
+		writel(reg, i2c_reg->CON & (~I2C_CON_MASTER_MODE_MASK));
 		/* Set slave address */
-		i2c_reg->SAR = i2c->owner_addr;
+		reg = &i2c_reg->SAR;
+		writel(reg, i2c->owner_addr);
 	}
 	i2c_config->operation_mode = i2c->operation_mode;
 
 	/* Set address mode */
 	if (I2C_7BIT == i2c->address_mode)
 	{
-		i2c_reg->CON &= (~I2C_CON_10BITADDR_MASTER_MASK);
-		i2c_reg->CON &= (~I2C_CON_10BITADDR_SLAVE_MASK);
-		i2c_reg->TAR &= (~I2C_TAR_10BITADDR_MASTER_MASK);
+		reg = &i2c_reg->CON;
+		writel(reg, i2c_reg->CON & (~I2C_CON_10BITADDR_MASTER_MASK));
+		writel(reg, i2c_reg->CON & (~I2C_CON_10BITADDR_SLAVE_MASK));
+		reg = &i2c_reg->TAR;
+		writel(reg, i2c_reg->TAR & (~I2C_TAR_10BITADDR_MASTER_MASK));
 	}
 	else
 	{
-		i2c_reg->CON |= I2C_CON_10BITADDR_MASTER_MASK;
-		i2c_reg->CON |= I2C_CON_10BITADDR_SLAVE_MASK;
-		i2c_reg->TAR |= I2C_TAR_10BITADDR_MASTER_MASK;
+		reg = &i2c_reg->CON;
+		writel(reg, i2c_reg->CON | I2C_CON_10BITADDR_MASTER_MASK);
+		writel(reg, i2c_reg->CON | I2C_CON_10BITADDR_SLAVE_MASK);
+		reg = &i2c_reg->TAR;
+		writel(reg, i2c_reg->TAR | I2C_TAR_10BITADDR_MASTER_MASK);
 	}
 	i2c_config->address_mode = i2c->address_mode;
 
@@ -375,30 +382,39 @@ void hal_i2c_init(hal_i2c_t *i2c)
 	input_clock_khz = I2C_CLK / 1000;
 	if (I2C_SPEED_100KHz == i2c->clock_speed)
 	{
-		i2c_reg->CON = (i2c_reg->CON & (~I2C_CON_SPEED_MASK)) |
-						I2C_CON_SPEED_STANDARD;
+		reg = &i2c_reg->CON;
+		writel(reg, (i2c_reg->CON & (~I2C_CON_SPEED_MASK)) |
+				I2C_CON_SPEED_STANDARD);
 		/* tHD; STA = tHIGH = 4.0 us, tf = 0.3 us */
-		i2c_reg->SS_SCL_HCNT = (input_clock_khz * (40 + 3) + 5000)/10000 - 3;
+		reg = &i2c_reg->SS_SCL_HCNT;
+		writel(reg, (input_clock_khz * (40 + 3) + 5000)/10000 - 3);
 		/* tLOW = 4.7 us, tf = 0.3 us */
-		i2c_reg->SS_SCL_LCNT = ((input_clock_khz * (47 + 3) + 5000)/10000) - 1;
+		reg = &i2c_reg->SS_SCL_LCNT;
+		writel(reg, ((input_clock_khz * (47 + 3) + 5000)/10000) - 1);
 	}
 	else
 	{
-		i2c_reg->CON = (i2c_reg->CON & (~I2C_CON_SPEED_MASK)) |
-						I2C_CON_SPEED_FAST;
+		reg = &i2c_reg->CON;
+		writel(reg, (i2c_reg->CON & (~I2C_CON_SPEED_MASK)) |
+				I2C_CON_SPEED_FAST);
 		/* Set fast speed deviders for low periods */
 		/* tHD; STA = tHIGH = 0.6 us, tf = 0.3 us */
-		i2c_reg->FS_SCL_HCNT = (input_clock_khz * (6 + 3) + 5000)/10000 - 3;
+		reg = &i2c_reg->FS_SCL_HCNT;
+		writel(reg, (input_clock_khz * (6 + 3) + 5000)/10000 - 3);
 		/* tLOW = 1.3 us, tf = 0.3 us */
-		i2c_reg->FS_SCL_LCNT = ((input_clock_khz * (13 + 3) + 5000)/10000) - 1;
+		reg = &i2c_reg->FS_SCL_LCNT;
+		writel(reg, ((input_clock_khz * (13 + 3) + 5000)/10000) - 1);
 	}
 
 	/* Disable start byte */
-	i2c_reg->TAR &= (~I2C_TAR_GC_OR_START_MASK);
+	reg = &i2c_reg->TAR;
+	writel(reg, i2c_reg->TAR & (~I2C_TAR_GC_OR_START_MASK));
 	/* Enable RESTART condition */
-	i2c_reg->CON |= I2C_CON_RESTART_EN_MASK;
+	reg = &i2c_reg->CON;
+	writel(reg, i2c_reg->CON | I2C_CON_RESTART_EN_MASK);
 	/* Disable all interrupts */
-	i2c_reg->INTR_MASK = 0;
+	reg = &i2c_reg->INTR_MASK;
+	writel(reg, 0x00);
 
 	/* Set initialization status */
 	i2c_config->init_status = I2C_INIT_INITIALIZED;
@@ -406,8 +422,10 @@ void hal_i2c_init(hal_i2c_t *i2c)
 	i2c_config->state_machine = I2C_IDLE;
 
 	/* Set Tx/Rx FIFO threshold levels to 1 entry */
-	i2c_reg->TX_TL = 0;
-	i2c_reg->RX_TL = 0;
+	reg = &i2c_reg->TX_TL;
+	writel(reg, 0x00);
+	reg = &i2c_reg->RX_TL;
+	writel(reg, 0x00);
 	/* Clear soft FIFO buffers */
 	i2c_config->tx_soft_fifo[0].length = 0;
 	i2c_config->rx_soft_fifo[0].length = 0;
@@ -415,7 +433,8 @@ void hal_i2c_init(hal_i2c_t *i2c)
 	i2c_config->rx_soft_fifo_current_index = 0;
 
 	/* Enable the selected i2c channel */
-	i2c_reg->EN = 1;
+	reg = &i2c_reg->EN;
+	writel(reg, 0x01);
 }
 
 /*
@@ -426,11 +445,13 @@ void hal_i2c_init(hal_i2c_t *i2c)
  */
 void hal_i2c_deinit(hal_i2c_channel_t chid)
 {
+	__IO uint32_t* reg = NULL;
 	/* Assert input parameters */
 	assert_param(IS_I2C_CHANNEL(chid));
 
 	/* Disable i2c channel */
-	i2c_configs[chid].i2c_base->EN = 0;
+	reg = &i2c_configs[chid].i2c_base->EN;
+	writel(reg, 0x00);
 	/* Disable interrupt */
 	hal_i2c_disable_irq(chid);
 	/* Update initialization status */
@@ -451,6 +472,7 @@ int hal_i2c_master_tx(hal_i2c_channel_t chid,
 	i2c_config_t	*i2c_config;
 	int					timeout;
 	int					ret = I2C_OK;
+	__IO uint32_t* reg = NULL;
 
 	/* Assert input parameters */
 	assert_param(NULL != buf);
@@ -482,12 +504,15 @@ int hal_i2c_master_tx(hal_i2c_channel_t chid,
 		i2c_set_next_tx_threshold(chid);
 
 		/* Disable the selected i2c channel for writing target address */
-		i2c_reg->EN = 0;
+		reg = &i2c_reg->EN;
+		writel(reg, 0x00);
 		/* Set slave address */
-		i2c_reg->TAR &= (~I2C_TAR_TAR_MASK);
-		i2c_reg->TAR |= slave_addr;
+		reg = &i2c_reg->TAR;
+		writel(reg, i2c_reg->TAR & (~I2C_TAR_TAR_MASK));
+		writel(reg, i2c_reg->TAR | slave_addr);
 		/* Enable the selected i2c channel */
-		i2c_reg->EN = 1;
+		reg = &i2c_reg->EN;
+		writel(reg, 0x01);
 		/*
 		 * Push the first soft Tx FIFO buffer into hard Tx FIFO
 		 * to transmit them and wait to get Tx completion interrupt
@@ -512,6 +537,7 @@ int hal_i2c_master_rx(hal_i2c_channel_t chid,
 	i2c_config_t	*i2c_config;
 	int					timeout;
 	int					ret = I2C_OK;
+	__IO uint32_t* reg = NULL;
 
 	/* Assert input parameters */
 	assert_param(NULL != buf);
@@ -546,17 +572,21 @@ int hal_i2c_master_rx(hal_i2c_channel_t chid,
 		/* Set Tx FIFO threshold for triggering next TX_EMPTY interrupt */
 		i2c_set_next_tx_threshold(chid);
 		/* Set Rx FIFO threshold for triggering RX_FULL interrupt */
-		i2c_reg->RX_TL = i2c_config->rx_soft_fifo[0].length - 1;
+		reg = &i2c_reg->RX_TL;
+		writel(reg, i2c_config->rx_soft_fifo[0].length - 1);
 
 		/* Start to request data */
 
 		/* Disable the selected i2c channel for writing target address */
-		i2c_reg->EN = 0;
+		reg = &i2c_reg->EN;
+		writel(reg, 0x00);
 		/* Set slave address */
-		i2c_reg->TAR &= (~I2C_TAR_TAR_MASK);
-		i2c_reg->TAR |= slave_addr;
+		reg = &i2c_reg->TAR;
+		writel(reg, i2c_reg->TAR & (~I2C_TAR_TAR_MASK));
+		writel(reg, i2c_reg->TAR | slave_addr);
 		/* Enable the selected i2c channel */
-		i2c_reg->EN = 1;
+		reg = &i2c_reg->EN;
+		writel(reg, 0x01);
 
 		i2c_master_rx(chid);
 	}
@@ -576,7 +606,7 @@ int hal_i2c_slave_tx(hal_i2c_channel_t chid, hal_i2c_buffer_t *buf)
 	i2c_config_t	*i2c_config;
 	int					timeout;
 	int					ret = I2C_OK;
-
+	__IO uint32_t* reg = NULL;
 	/* Assert input parameters */
 	assert_param(NULL != buf);
 	assert_param(IS_I2C_CHANNEL(chid));
@@ -603,10 +633,15 @@ int hal_i2c_slave_tx(hal_i2c_channel_t chid, hal_i2c_buffer_t *buf)
 		/* Set state machine */
 		i2c_config->state_machine = I2C_TX_TRASMITTING;
 		/* Set Tx FIFO threshold for triggering next TX_EMPTY interrupt */
+		reg = &i2c_reg->TX_TL;
 		if (0 < i2c_config->tx_soft_fifo[1].length)
-			i2c_reg->TX_TL = i2c_config->tx_soft_fifo[0].length - 1;
+		{
+			writel(reg, i2c_config->tx_soft_fifo[0].length - 1);
+		}
 		else
-			i2c_reg->TX_TL = 0;
+		{
+			writel(reg, 0x00);
+		}
 
 		/*
 		 * Push the first soft Tx FIFO buffer into hard Tx FIFO
@@ -674,26 +709,29 @@ void hal_i2c_enable_irq(hal_i2c_t *i2c)
 	assert_param(NULL != i2c);
 	assert_param(IS_I2C_CHANNEL(i2c->chid));
 	assert_param(I2C_INIT_INITIALIZED == i2c_configs[i2c->chid].init_status);
+	__IO uint32_t* reg = NULL;
 
 	i2c_reg = i2c_configs[i2c->chid].i2c_base;
 
+	reg = &i2c_reg->INTR_MASK;
 	/* Enable RX_DONE interrupt */
-	i2c_reg->INTR_MASK |= I2C_INTR_MASK_RX_DONE_MASK;
+	writel(reg, i2c_reg->INTR_MASK | I2C_INTR_MASK_RX_DONE_MASK);
 	/* Enable TX_ABRT interrupt */
-	i2c_reg->INTR_MASK |= I2C_INTR_MASK_TX_ABRT_MASK;
+	writel(reg, i2c_reg->INTR_MASK | I2C_INTR_MASK_TX_ABRT_MASK);
 	/* Enable RD_REQ interrupt */
-	i2c_reg->INTR_MASK |= I2C_INTR_MASK_RD_REQ_MASK;
+	writel(reg, i2c_reg->INTR_MASK | I2C_INTR_MASK_RD_REQ_MASK);
 	/* Enable RX_FULL interrupt */
-	i2c_reg->INTR_MASK |= I2C_INTR_MASK_RX_FULL_MASK;
+	writel(reg, i2c_reg->INTR_MASK | I2C_INTR_MASK_RX_FULL_MASK);
 	/* Enable STOP Detection interrupt */
-	i2c_reg->INTR_MASK |= I2C_INTR_MASK_STOP_DET_MASK;
+	writel(reg, i2c_reg->INTR_MASK | I2C_INTR_MASK_STOP_DET_MASK);
 	/* Enable RESTART Detection interrupt */
-	i2c_reg->INTR_MASK |= I2C_INTR_MASK_RESTART_DET_MASK;
+	writel(reg, i2c_reg->INTR_MASK | I2C_INTR_MASK_RESTART_DET_MASK);
 	/*
 	 * Generate TX_EMPTY interrupt when Tx shift register is not empty for
 	 * faster transmission
 	 */
-	i2c_reg->CON |= I2C_CON_TX_EMPTY_CONTROL_MASK;
+	reg = &i2c_reg->CON;
+	writel(reg, i2c_reg->CON | I2C_CON_TX_EMPTY_CONTROL_MASK);
 
 	/* Set interrupt handler */
 	i2c_configs[i2c->chid].irq_handler = i2c->irq_handler;
@@ -803,11 +841,13 @@ void hal_i2c_disable_irq(hal_i2c_channel_t chid)
 	/* Assert input parameters */
 	assert_param(IS_I2C_CHANNEL(chid));
 	assert_param(I2C_INIT_INITIALIZED == i2c_configs[chid].init_status);
+	__IO uint32_t* reg = NULL;
 
 	i2c_reg = i2c_configs[chid].i2c_base;
 
 	/* Disable all interrupts */
-	i2c_reg->INTR_MASK = 0;
+	reg = &i2c_reg->INTR_MASK;
+	writel(reg, 0x00);
 	/* Clear all pending interrupts */
 	i2c_reg->CLR_INTR;
 	/* Clear interrupt handler */
@@ -842,9 +882,11 @@ static void i2c_master_tx(hal_i2c_channel_t chid)
 	hal_i2c_buffer_t	*stxbuf = i2c_config->tx_soft_fifo;
 	uint16_t			tx_current_index;
 	uint16_t			i;
+	__IO uint32_t* reg = NULL;
 
 	tx_current_index = i2c_config->tx_soft_fifo_current_index;
 
+	reg = &i2c_reg->DATA_CMD;
 	for (i = 0; i < stxbuf[tx_current_index].length; i++)
 	{
 		/* Check if this is the last byte for transmission */
@@ -852,18 +894,19 @@ static void i2c_master_tx(hal_i2c_channel_t chid)
 			(0 == stxbuf[tx_current_index + 1].length))
 		{
 			/* Write data to FIFO and generate STOP condition */
-			i2c_reg->DATA_CMD = stxbuf[tx_current_index].bytes[i] |
-								I2C_DATA_CMD_STOP_MASK;
+			writel(reg, stxbuf[tx_current_index].bytes[i] |
+					I2C_DATA_CMD_STOP_MASK);
 		}
 		else
 		{
 			/* Write data to FIFO */
-			i2c_reg->DATA_CMD = stxbuf[tx_current_index].bytes[i];
+			writel(reg, stxbuf[tx_current_index].bytes[i]);
 		}
 	}
 
 	/* Enable TX_EMPTY interrupt */
-	i2c_reg->INTR_MASK |= I2C_INTR_MASK_TX_EMPTY_MASK;
+	reg = &i2c_reg->INTR_MASK;
+	writel(reg, i2c_reg->INTR_MASK | I2C_INTR_MASK_TX_EMPTY_MASK);
 }
 
 /*
@@ -878,9 +921,11 @@ static void i2c_master_rx(hal_i2c_channel_t chid)
 	hal_i2c_buffer_t	*stxbuf = i2c_config->tx_soft_fifo;
 	uint16_t			tx_current_index;
 	uint16_t			i;
+	__IO uint32_t* reg = NULL;
 
 	tx_current_index = i2c_config->tx_soft_fifo_current_index;
 
+	reg = &i2c_reg->DATA_CMD;
 	for (i = 0; i < stxbuf[tx_current_index].length; i++)
 	{
 		/* Check if this is the last read request */
@@ -888,17 +933,18 @@ static void i2c_master_rx(hal_i2c_channel_t chid)
 			(0 == stxbuf[tx_current_index + 1].length))
 		{
 			/* Read data from slave and generate STOP condition */
-			i2c_reg->DATA_CMD = I2C_DATA_CMD_CMD_MASK | I2C_DATA_CMD_STOP_MASK;
+			writel(reg, I2C_DATA_CMD_CMD_MASK | I2C_DATA_CMD_STOP_MASK);
 		}
 		else
 		{
 			/* Request data from slave */
-			i2c_reg->DATA_CMD = I2C_DATA_CMD_CMD_MASK;
+			writel(reg, I2C_DATA_CMD_CMD_MASK);
 		}
 	}
 
 	/* Enable TX_EMPTY interrupt */
-	i2c_reg->INTR_MASK |= I2C_INTR_MASK_TX_EMPTY_MASK;
+	reg = &i2c_reg->INTR_MASK;
+	writel(reg, i2c_reg->INTR_MASK | I2C_INTR_MASK_TX_EMPTY_MASK);
 }
 
 /*
@@ -913,15 +959,18 @@ static void i2c_slave_tx(hal_i2c_channel_t chid)
 	hal_i2c_buffer_t	*stxbuf = i2c_config->tx_soft_fifo;
 	uint16_t			tx_current_index;
 	uint16_t			i;
+	__IO uint32_t* reg = NULL;
 
 	tx_current_index = i2c_config->tx_soft_fifo_current_index;
 
 	/* Write data to FIFO */
+	reg = &i2c_reg->DATA_CMD;
 	for (i = 0; i < stxbuf[tx_current_index].length; i++)
-		i2c_reg->DATA_CMD = stxbuf[tx_current_index].bytes[i];
+		writel(reg, stxbuf[tx_current_index].bytes[i]);
 
 	/* Enable TX_EMPTY interrupt */
-	i2c_reg->INTR_MASK |= I2C_INTR_MASK_TX_EMPTY_MASK;
+	reg = &i2c_reg->INTR_MASK;
+	writel(reg, i2c_reg->INTR_MASK | I2C_INTR_MASK_TX_EMPTY_MASK);
 }
 
 /*
@@ -932,6 +981,7 @@ static void i2c_isr_handler(hal_i2c_channel_t chid)
 {
 	i2c_config_t	*i2c_config = &(i2c_configs[chid]);
 	i2c_reg_t		*i2c_reg = i2c_config->i2c_base;
+	__IO uint32_t*   reg = NULL;
 
 	/* Check if TX_EMPTY interrupt occurred */
 	if (i2c_reg->INTR_STAT & I2C_INTR_STAT_TX_EMPTY_MASK)
@@ -940,7 +990,8 @@ static void i2c_isr_handler(hal_i2c_channel_t chid)
 		uint16_t			tx_next_index;
 
 		/* Disable TX_EMPTY interrupt */
-		i2c_reg->INTR_MASK &= (~I2C_INTR_MASK_TX_EMPTY_MASK);
+		reg = &i2c_reg->INTR_MASK;
+		writel(reg, i2c_reg->INTR_MASK & (~I2C_INTR_MASK_TX_EMPTY_MASK));
 
 		tx_next_index = i2c_config->tx_soft_fifo_current_index + 1;
 
@@ -1003,7 +1054,8 @@ static void i2c_isr_handler(hal_i2c_channel_t chid)
 			{
 				/* Set in order to receive the next data */
 				i2c_config->rx_soft_fifo_current_index++;
-				i2c_reg->RX_TL = srxbuf[rx_current_index + 1].length - 1;
+				reg = &i2c_reg->RX_TL;
+				writel(reg, srxbuf[rx_current_index + 1].length - 1);
 			}
 		}
 		/* If i2c channel is operating as a slave-receiver */
@@ -1083,6 +1135,7 @@ static void i2c_set_next_tx_threshold(hal_i2c_channel_t chid)
 	i2c_config_t	*i2c_config = &(i2c_configs[chid]);
 	i2c_reg_t		*i2c_reg = i2c_config->i2c_base;
 	uint16_t			tx_next_index;
+	__IO uint32_t*   reg = NULL;
 
 	/* Get next soft Tx FIFO buffer index for transmission */
 	tx_next_index = i2c_config->tx_soft_fifo_current_index + 1;
@@ -1091,6 +1144,7 @@ static void i2c_set_next_tx_threshold(hal_i2c_channel_t chid)
 	 * Check if the next soft Tx FIFO buffer is not the last buffer
 	 * for transmission
 	 */
+	reg = &i2c_reg->TX_TL;
 	if (0 < i2c_config->tx_soft_fifo[tx_next_index + 1].length)
 	{
 		/*
@@ -1099,12 +1153,12 @@ static void i2c_set_next_tx_threshold(hal_i2c_channel_t chid)
 		 * (then hardware Tx FIFO reaches to a half size)
 		 * in order to push another soft Tx FIFO buffer to hardware Tx FIFO
 		 */
-		i2c_reg->TX_TL = i2c_config->tx_soft_fifo[tx_next_index].length - 1;
+		writel(reg, i2c_config->tx_soft_fifo[tx_next_index].length - 1);
 	}
 	else
 	{
 		/* Trigger TX_EMPTY interrupt when hardware Tx FIFO is empty */
-		i2c_reg->TX_TL = 0;
+		writel(reg, 0x00);
 	}
 }
 
diff --git a/platform/asic/hal/src/hal_pwm.c b/platform/asic/hal/src/hal_pwm.c
index d622611..ca048af 100644
--- a/platform/asic/hal/src/hal_pwm.c
+++ b/platform/asic/hal/src/hal_pwm.c
@@ -18,6 +18,7 @@
 #include "cortex_r4.h"
 #include "hal_vic.h"
 #include "hal_pwm.h"
+#include "std_type.h"
 
 
 /** #ASIC Hardware target */
@@ -181,8 +182,8 @@ void hal_pwm_init(hal_pwm_channel_t pwm_channel,
 	pwmx = hw_pwm[pwm_channel].pwmx;
 
 	/* Set alignment mode */
-	pwmx->MODE = (pwmx->MODE & (~PWM_MODE_PWMMODE_MASK)) |
-					pwm_init_config->align_mode;
+	__IO uint32_t* reg = &(pwmx->MODE);
+	writel(reg, (pwmx->MODE & (~PWM_MODE_PWMMODE_MASK)) | pwm_init_config->align_mode);
 	/* Store align mode */
 	hw_pwm[pwm_channel].align = pwm_init_config->align_mode;
 	/* Store output generation mode */
@@ -210,20 +211,22 @@ void hal_pwm_start(hal_pwm_channel_t pwm_channel)
 	/* Update state machine */
 	hw_pwm[pwm_channel].state = PWM_STARTED;
 
+	__IO uint32_t* reg = &pwmx->MODE;
+
 	/* Set output generation mode and start generating PWM output signal */
 	if (PWM_CONTINUOUS == hw_pwm[pwm_channel].mode)
 	{
 		/* Disable number of patterns mode */
-		pwmx->MODE &= (~PWM_MODE_PATTERNMODEEN_MASK);
+		writel(reg, pwmx->MODE & (~PWM_MODE_PATTERNMODEEN_MASK));
 		/* Enable continuous mode */
-		pwmx->MODE |= PWM_MODE_CONTMMODEEN_MASK;
+		writel(reg, pwmx->MODE | PWM_MODE_CONTMMODEEN_MASK);
 	}
 	else
 	{
 		/* Disable continuous mode */
-		pwmx->MODE &= (~PWM_MODE_CONTMMODEEN_MASK);
+		writel(reg, pwmx->MODE & (~PWM_MODE_CONTMMODEEN_MASK));
 		/* Enable number of patterns mode */
-		pwmx->MODE |= PWM_MODE_PATTERNMODEEN_MASK;
+		writel(reg, pwmx->MODE | PWM_MODE_PATTERNMODEEN_MASK);
 	}
 }
 
@@ -236,9 +239,14 @@ void hal_pwm_stop(hal_pwm_channel_t pwm_channel)
 	/* Check parameters */
 	assert_param(IS_PWM_CHANNEL(pwm_channel));
 
+	__IO uint32_t* reg = &hw_pwm[pwm_channel].pwmx->MODE;
 	/* Stop generating PWM output signal */
-	hw_pwm[pwm_channel].pwmx->MODE &= (~PWM_MODE_CONTMMODEEN_MASK);
-	hw_pwm[pwm_channel].pwmx->MODE &= (~PWM_MODE_PATTERNMODEEN_MASK);
+	writel(reg,   \
+			hw_pwm[pwm_channel].pwmx->MODE & \
+			(~PWM_MODE_CONTMMODEEN_MASK));
+	writel(reg,   \
+			hw_pwm[pwm_channel].pwmx->MODE & \
+			(~PWM_MODE_PATTERNMODEEN_MASK));
 
 	/* Update state machine */
 	hw_pwm[pwm_channel].state = PWM_STOPPED;
@@ -253,7 +261,7 @@ void hal_pwm_update(hal_pwm_channel_t pwm_channel, hal_pwm_output_t *pwm_value)
 	uint32_t period;
 	uint32_t duty_cycle;
 	uint8_t i;
-
+	__IO uint32_t* reg = NULL;
 	/* Check parameters */
 	assert_param(IS_PWM_CHANNEL(pwm_channel));
 	assert_param(NULL != pwm_value);
@@ -268,9 +276,15 @@ void hal_pwm_update(hal_pwm_channel_t pwm_channel, hal_pwm_output_t *pwm_value)
 	/* Configure frequency */
 	period = BOARD_PCLOCK / pwm_value->freq;
 	if (PWM_ALIGN_CENTER != hw_pwm[pwm_channel].align)
-		hw_pwm[pwm_channel].pwmx->ARLDV = period - 1;
+	{
+		reg = &hw_pwm[pwm_channel].pwmx->ARLDV;
+		writel(reg, period - 1);
+	}
 	else
-		hw_pwm[pwm_channel].pwmx->ARLDV = period >> 1;
+	{
+		reg = &hw_pwm[pwm_channel].pwmx->ARLDV;
+		writel(reg, period >> 1);
+	}
 
 	/* Configure patterns */
 	for (i = 0; i < pwm_value->pattern.num_pairs; i++)
@@ -278,24 +292,33 @@ void hal_pwm_update(hal_pwm_channel_t pwm_channel, hal_pwm_output_t *pwm_value)
 		/* Duty cycle for pairs */
 		duty_cycle = (pwm_value->pattern.pair[i].duty * period) / 100;
 		if (PWM_ALIGN_CENTER != hw_pwm[pwm_channel].align)
-			hw_pwm[pwm_channel].pwmx->PAIRS[i].DUTYV = duty_cycle;
+		{
+			reg = &(hw_pwm[pwm_channel].pwmx->PAIRS[i].DUTYV);
+			writel(reg, duty_cycle);
+		}
 		else
-			hw_pwm[pwm_channel].pwmx->PAIRS[i].DUTYV = duty_cycle >> 1;
+		{
+			reg = &(hw_pwm[pwm_channel].pwmx->PAIRS[i].DUTYV);
+			writel(reg, duty_cycle >> 1);
+		}
+		reg = &(hw_pwm[pwm_channel].pwmx->PAIRS[i].NUMPV);
 		/* The number of pulses for pairs */
-		hw_pwm[pwm_channel].pwmx->PAIRS[i].NUMPV =
-										pwm_value->pattern.pair[i].num_pulses;
+		writel(reg, pwm_value->pattern.pair[i].num_pulses);
 	}
 	/* Disable the unused pairs */
 	for (; i < 3; i++)
-		hw_pwm[pwm_channel].pwmx->PAIRS[i].NUMPV = 0;
+	{
+		reg = &(hw_pwm[pwm_channel].pwmx->PAIRS[i].NUMPV);
+		writel(reg, 0);
+	}
 
 	/*
 	 * Set the number of patterns
 	 * corresponding to the configured output generation mode
 	 */
-	hw_pwm[pwm_channel].pwmx->NUMPATS =
-				(hw_pwm[pwm_channel].mode == PWM_FIXED_PATTERNS) ?
-										pwm_value->num_patterns : 0;
+	reg = &(hw_pwm[pwm_channel].pwmx->NUMPATS);
+	writel(reg, (hw_pwm[pwm_channel].mode == PWM_FIXED_PATTERNS) ?
+										pwm_value->num_patterns : 0);
 
 	/* Take effect if PWM channel is running */
 	if (PWM_STARTED == hw_pwm[pwm_channel].state)
@@ -316,11 +339,14 @@ void hal_pwm_enable_irq(hal_pwm_channel_t pwm_channel,
 					pwm_intr_config->irq_mode));
 	assert_param(NULL != pwm_intr_config->callback_handler);
 
+	__IO uint32_t* reg = NULL;
+
 	/* Set interrupt handler */
 	hw_pwm[pwm_channel].callback_handler = pwm_intr_config->callback_handler;
 	hw_pwm[pwm_channel].is_irq_enabled = TRUE;
 	/* Enable interrupt */
-	hw_pwm[pwm_channel].pwmx->INTREN = pwm_intr_config->irq_mode;
+	reg = &(hw_pwm[pwm_channel].pwmx->INTREN);
+	writel(reg, pwm_intr_config->irq_mode);
 	/* register interrupt handler */
 	if ((PWM0_CH1 <= pwm_channel) && (PWM0_CH6 >= pwm_channel))
 		vic_register_irq(PWM0_IRQn, PWM0_IRQHandler);
@@ -338,11 +364,13 @@ void hal_pwm_disable_irq(hal_pwm_channel_t pwm_channel)
 
 	/* Check parameters */
 	assert_param(IS_PWM_CHANNEL(pwm_channel));
-
+	__IO uint32_t* reg = NULL;
 	/* Disable all interrupts */
-	hw_pwm[pwm_channel].pwmx->INTREN = 0;
+	reg = &(hw_pwm[pwm_channel].pwmx->INTREN);
+	writel(reg, 0);
 	/* clear all pending interrupts */
-	hw_pwm[pwm_channel].pwmx->INTRSTAT = 0xFFFFFFFF;
+	reg = &(hw_pwm[pwm_channel].pwmx->INTRSTAT);
+	writel(reg, 0xFFFFFFFF);
 	/* clear interrupt handler */
 	hw_pwm[pwm_channel].callback_handler = NULL;
 	hw_pwm[pwm_channel].is_irq_enabled = FALSE;
@@ -372,7 +400,7 @@ void hal_pwm_disable_irq(hal_pwm_channel_t pwm_channel)
 void hal_pwm_set_high(hal_pwm_channel_t pwm_channel)
 {
 	pwm_reg_t	*pwmx;
-
+	__IO uint32_t* reg = NULL;
 	/* Check parameters */
 	assert_param(IS_PWM_CHANNEL(pwm_channel));
 	/* Get PWM channel base address */
@@ -380,7 +408,8 @@ void hal_pwm_set_high(hal_pwm_channel_t pwm_channel)
 
 	hal_pwm_stop(pwm_channel);
 	/* set pwm_p output value*/
-	pwmx->MODE = (pwmx->MODE & (~0x200000)) | 0x100000;
+	reg = &pwmx->MODE;
+	writel(reg, (pwmx->MODE & (~0x200000)) | 0x100000);
 }
 
 /**
@@ -390,7 +419,7 @@ void hal_pwm_set_high(hal_pwm_channel_t pwm_channel)
 void hal_pwm_set_low(hal_pwm_channel_t pwm_channel)
 {
 	pwm_reg_t	*pwmx;
-
+	__IO uint32_t* reg = NULL;
 	/* Check parameters */
 	assert_param(IS_PWM_CHANNEL(pwm_channel));
 	/* Get PWM channel base address */
@@ -398,7 +427,8 @@ void hal_pwm_set_low(hal_pwm_channel_t pwm_channel)
 
 	hal_pwm_stop(pwm_channel);
 	/* set pwm_n output value*/
-	pwmx->MODE = (pwmx->MODE & (~0x100000)) | 0x200000;
+	reg = &pwmx->MODE;
+	writel(reg, (pwmx->MODE & (~0x100000)) | 0x200000);
 }
 
 /* Private functions --------- ----------------------------------------------*/
@@ -410,21 +440,23 @@ void hal_pwm_set_low(hal_pwm_channel_t pwm_channel)
 static void hal_pwm_isr(int chid)
 {
 	pwm_reg_t	*pwmx = hw_pwm[chid].pwmx;
-
+	__IO uint32_t* reg = NULL;
 	/* check if ONE_PATTERN_GENERATED interrupt occurred */
 	if (PWM_IRQ_ONE_PATTERN_GENERATED ==
 								(pwmx->INTRSTAT & PWM_IRQ_ONE_PATTERN_GENERATED))
 	{
+		reg = &pwmx->INTRSTAT;
 		/* Clear pending interrupt */
-		pwmx->INTRSTAT |= PWM_IRQ_ONE_PATTERN_GENERATED;
+		writel(reg, pwmx->INTRSTAT | PWM_IRQ_ONE_PATTERN_GENERATED);
 		/* call back to upper layer function */
 		hw_pwm[chid].callback_handler(chid);
 	}
 	/* if ALL_PATTERNS_GENERATED interrupt occurred */
 	else
 	{
+		reg = &pwmx->INTRSTAT;
 		/* Clear pending interrupt */
-		pwmx->INTRSTAT |= PWM_IRQ_ALL_PATTERNS_GENERATED;
+		writel(reg, pwmx->INTRSTAT | PWM_IRQ_ALL_PATTERNS_GENERATED);
 		/* call back to upper layer function */
 		hw_pwm[chid].callback_handler(chid);
 	}
diff --git a/platform/asic/hal/src/hal_qspi.c b/platform/asic/hal/src/hal_qspi.c
index 19638e4..5243f20 100644
--- a/platform/asic/hal/src/hal_qspi.c
+++ b/platform/asic/hal/src/hal_qspi.c
@@ -68,6 +68,7 @@ static qspi_status_t qspi_wait_busy(void)
 qspi_status_t transfer_cmd(qspi_transfer_cmd_t *qspi_transfer_cmd)
 {
 	uint32_t *tmp;
+	__IO uint32_t* reg = NULL;
 
 	/* check parameters */
 	assert_param(qspi_transfer_cmd);
@@ -77,7 +78,8 @@ qspi_status_t transfer_cmd(qspi_transfer_cmd_t *qspi_transfer_cmd)
 	assert_param(qspi_transfer_cmd->rx_buff_reg);
 	assert_param(qspi_transfer_cmd->rx_buff_reg8);
 
-	QSPI_ADDR->SPI_MODE	= qspi_transfer_cmd->spi_mode_reg;
+	reg = &QSPI_ADDR->SPI_MODE;
+	writel(reg, qspi_transfer_cmd->spi_mode_reg);
 
 	if(qspi_transfer_cmd->spi_mode_reg == PIO1_GO_MODE)
 	{
@@ -87,14 +89,19 @@ qspi_status_t transfer_cmd(qspi_transfer_cmd_t *qspi_transfer_cmd)
 				(qspi_transfer_cmd->pio_mode1.pio_step0_conf.pio_output_en));
 
 		tmp = (uint32_t *) &qspi_transfer_cmd->pio_mode1.pio_step0_conf;
-		QSPI_ADDR->PIO1_STEP0_CONF	= (uint32_t) (*tmp & 0xFFFFFF);
+		reg = &QSPI_ADDR->PIO1_STEP0_CONF;
+		writel(reg, (uint32_t) (*tmp & 0xFFFFFF));
 		tmp = (uint32_t *) &qspi_transfer_cmd->pio_mode1.pio_step1_conf;
-		QSPI_ADDR->PIO1_STEP1_CONF	= (uint32_t) (*tmp & 0xFFFFFF);
+		reg = &QSPI_ADDR->PIO1_STEP1_CONF;
+		writel(reg, (uint32_t) (*tmp & 0xFFFFFF));
 		tmp = (uint32_t *) &qspi_transfer_cmd->pio_mode1.pio_step2_conf;
-		QSPI_ADDR->PIO1_STEP2_CONF	= (uint32_t) (*tmp & 0xFFFFFF);
+		reg = &QSPI_ADDR->PIO1_STEP2_CONF;
+		writel(reg, (uint32_t) (*tmp & 0xFFFFFF));
 		tmp = (uint32_t *) &qspi_transfer_cmd->pio_mode1.pio_step3_conf;
-		QSPI_ADDR->PIO1_STEP3_CONF	= (uint32_t) (*tmp & 0xFFFFFF);
-		QSPI_ADDR->PIO1_GO			= ENABLE_SPI_MODE;
+		reg = &QSPI_ADDR->PIO1_STEP3_CONF;
+		writel(reg, (uint32_t) (*tmp & 0xFFFFFF));
+		reg = &QSPI_ADDR->PIO1_GO;
+		writel(reg, ENABLE_SPI_MODE);
 	}
 	else if(qspi_transfer_cmd->spi_mode_reg == PIO2_GO_MODE)
 	{
@@ -104,14 +111,19 @@ qspi_status_t transfer_cmd(qspi_transfer_cmd_t *qspi_transfer_cmd)
 				(qspi_transfer_cmd->pio_mode2.pio_step0_conf.pio_output_en));
 
 		tmp = (uint32_t *) &qspi_transfer_cmd->pio_mode2.pio_step0_conf;
-		QSPI_ADDR->PIO2_STEP0_CONF	= (uint32_t) (*tmp & 0xFFFFFF);
+		reg = &QSPI_ADDR->PIO2_STEP0_CONF;
+		writel(reg, (uint32_t) (*tmp & 0xFFFFFF));
 		tmp = (uint32_t *) &qspi_transfer_cmd->pio_mode2.pio_step1_conf;
-		QSPI_ADDR->PIO2_STEP1_CONF	= (uint32_t) (*tmp & 0xFFFFFF);
+		reg = &QSPI_ADDR->PIO2_STEP1_CONF;
+		writel(reg, (uint32_t) (*tmp & 0xFFFFFF));
 		tmp = (uint32_t *) &qspi_transfer_cmd->pio_mode2.pio_step2_conf;
-		QSPI_ADDR->PIO2_STEP2_CONF	= (uint32_t) (*tmp & 0xFFFFFF);
+		reg = &QSPI_ADDR->PIO2_STEP2_CONF;
+		writel(reg, (uint32_t) (*tmp & 0xFFFFFF));
 		tmp = (uint32_t *) &qspi_transfer_cmd->pio_mode2.pio_step3_conf;
-		QSPI_ADDR->PIO2_STEP3_CONF	= (uint32_t) (*tmp & 0xFFFFFF);
-		QSPI_ADDR->PIO2_GO			= ENABLE_SPI_MODE;
+		reg = &QSPI_ADDR->PIO2_STEP3_CONF;
+		writel(reg, (uint32_t) (*tmp & 0xFFFFFF));
+		reg = &QSPI_ADDR->PIO2_GO;
+		writel(reg, ENABLE_SPI_MODE);
 	}
 	else if(qspi_transfer_cmd->spi_mode_reg == PP_GO_MODE)
 	{
@@ -124,18 +136,26 @@ qspi_status_t transfer_cmd(qspi_transfer_cmd_t *qspi_transfer_cmd)
 		assert_param(IS_QSPI_LANES\
 				(qspi_transfer_cmd->pp_mode.pp_dummy_conf.pp_lanes));
 
-		QSPI_ADDR->PP_CMD_CODE		= qspi_transfer_cmd->pp_mode.pp_cmd_code;
+		reg = &QSPI_ADDR->PP_CMD_CODE;
+		writel(reg, qspi_transfer_cmd->pp_mode.pp_cmd_code);
 		tmp = (uint32_t *) &qspi_transfer_cmd->pp_mode.pp_cmd_conf;
-		QSPI_ADDR->PP_CMD_CONF		= (uint32_t) (*tmp & 0x7FFFF);
-		QSPI_ADDR->PP_ADDR_CODE		= qspi_transfer_cmd->pp_mode.pp_addr_code;
+		reg = &QSPI_ADDR->PP_CMD_CONF;
+		writel(reg, (uint32_t) (*tmp & 0x7FFFF));
+		reg = &QSPI_ADDR->PP_ADDR_CODE;
+		writel(reg, qspi_transfer_cmd->pp_mode.pp_addr_code);
 		tmp = (uint32_t *) &qspi_transfer_cmd->pp_mode.pp_addr_conf;
-		QSPI_ADDR->PP_ADDR_CONF		= (uint32_t) (*tmp & 0x7FFFF);
-		QSPI_ADDR->PP_DUMMY_CODE	= qspi_transfer_cmd->pp_mode.pp_dummy_code;
+		reg = &QSPI_ADDR->PP_ADDR_CONF;
+		writel(reg, (uint32_t) (*tmp & 0x7FFFF));
+		reg = &QSPI_ADDR->PP_DUMMY_CODE;
+		writel(reg, qspi_transfer_cmd->pp_mode.pp_dummy_code);
 		tmp = (uint32_t *) &qspi_transfer_cmd->pp_mode.pp_dummy_conf;
-		QSPI_ADDR->PP_DUMMY_CONF	= (uint32_t) (*tmp & 0x7FFFF);
+		reg = &QSPI_ADDR->PP_DUMMY_CONF;
+		writel(reg, (uint32_t) (*tmp & 0x7FFFF));
 		tmp = (uint32_t *) &qspi_transfer_cmd->pp_mode.pp_data_conf;
-		QSPI_ADDR->PP_DATA_CONF		= (uint32_t) (*tmp & 0x7FFFF);
-		QSPI_ADDR->PP_GO			= ENABLE_SPI_MODE;
+		reg = &QSPI_ADDR->PP_DATA_CONF;
+		writel(reg, (uint32_t) (*tmp & 0x7FFFF));
+		reg = &QSPI_ADDR->PP_GO;
+		writel(reg, ENABLE_SPI_MODE);
 	}
 	return qspi_wait_busy();
 }
@@ -146,18 +166,19 @@ qspi_status_t transfer_cmd(qspi_transfer_cmd_t *qspi_transfer_cmd)
 void qspi_init(qspi_ctrl_mode_t *qspi_ctrl_mode)
 {
 	uint32_t *tmp;
-
+	__IO uint32_t* reg = NULL;
 	/* check parameters */
 	assert_param(qspi_ctrl_mode);
 
 	tmp = (uint32_t *) &qspi_ctrl_mode->pio1_ctrl;
-	QSPI_ADDR->PIO1_CTRL	= (uint32_t) (*tmp & 0x3FFFFFF);
-
+	reg = &QSPI_ADDR->PIO1_CTRL;
+	writel(reg, (uint32_t) (*tmp & 0x3FFFFFF));
 	tmp = (uint32_t *) &qspi_ctrl_mode->pio2_ctrl;
-	QSPI_ADDR->PIO2_CTRL	= (uint32_t) (*tmp & 0x3FFFFFF);
-
+	reg = &QSPI_ADDR->PIO2_CTRL;
+	writel(reg, (uint32_t) (*tmp & 0x3FFFFFF));
 	tmp = (uint32_t *) &qspi_ctrl_mode->pp_ctrl;
-	QSPI_ADDR->PP_CTRL		= (uint32_t) (*tmp & 0x3FFFFFF);
+	reg = &QSPI_ADDR->PP_CTRL;
+	writel(reg, (uint32_t) (*tmp & 0x3FFFFFF));
 }
 
 /*********** Portions COPYRIGHT 2016 Light.Co., Ltd. ********END OF FILE*******/
diff --git a/platform/asic/hal/src/hal_spi.c b/platform/asic/hal/src/hal_spi.c
index e0a1ce4..415220a 100644
--- a/platform/asic/hal/src/hal_spi.c
+++ b/platform/asic/hal/src/hal_spi.c
@@ -144,17 +144,17 @@ spi_status_t hal_spi_init(spi_config_t *spi)
 	assert_param(IS_SPI_TYPE(spi->spi_type));
 	assert_param(IS_SSI_MODE(spi->ssi_mode));
 	assert_param(IS_SSI_CHANNEL(spi->channel));
-
+	__IO uint32_t* reg = &spi_hw[spi->channel].spix->IMR;
 	/* Clear interrupt mark register */
-	spi_hw[spi->channel].spix->IMR = 0;
-
+	writel(reg, 0x00);
 	/* Disable SSI bit 0- Offset 0x08 - SSI Enable Register */
-	spi_hw[spi->channel].spix->SSIENR = 0;
-
+	reg = &spi_hw[spi->channel].spix->SSIENR;
+	writel(reg, 0x00);
 	/* Configure baud rate
 	 * Fclk_out = Fssi_clk/SCKDV Offset 0x14 - Baud Rate Select
 	 */
-	spi_hw[spi->channel].spix->BAUDR = BOARD_PCLOCK / spi->master_clk_freq;
+	reg = &spi_hw[spi->channel].spix->BAUDR;
+	writel(reg, BOARD_PCLOCK / spi->master_clk_freq);
 
 #ifdef TEST_LOOPBACK
 	control_0_reg |= (uint32_t)(1 << 11);
@@ -252,17 +252,19 @@ spi_status_t hal_spi_init(spi_config_t *spi)
 			control_0_reg &= ~(SPI_SLVOE);
 		}
 	}
-
-	spi_hw[spi->channel].spix->CTRL0 = control_0_reg;
-	spi_hw[spi->channel].spix->SSIENR = 1;
+	reg = &spi_hw[spi->channel].spix->CTRL0;
+	writel(reg, control_0_reg);
+	reg = &spi_hw[spi->channel].spix->SSIENR;
+	writel(reg, 0x01);
 
 	/* Configure number of data frame Offset 0x04 - Control Register 1 */
 	if(spi->channel == SSI_CH0
 		&& (spi->transfer_mode == RX_ONLY
 		|| spi->transfer_mode == EEPROM_READ))
 	{
+		reg = &spi_hw[spi->channel].spix->CTRL1;
 		/* Configure number of data frame */
-		spi_hw[spi->channel].spix->CTRL1 = spi->master_data_frame;
+		writel(reg, spi->master_data_frame);
 	}
 
 	return SPI_OK;
@@ -271,12 +273,13 @@ spi_status_t hal_spi_init(spi_config_t *spi)
 spi_status_t hal_spi_slave_select(uint8_t cs_pin, flag_status_t value)
 {
 	__IO uint32_t tmp = 0;
+	__IO uint32_t* reg = &spi_hw[SSI_CH0].spix->SER;
 
 	if(cs_pin >= 1 && cs_pin <= 32)
 	{
 		tmp = spi_hw[SSI_CH0].spix->SER;
 		tmp = (tmp & ~(1 << (cs_pin - 1))) | (value << (cs_pin - 1));
-		spi_hw[SSI_CH0].spix->SER = tmp;
+		writel(reg, tmp);
 		return SPI_OK;
 	}
 	return SPI_ERROR;
@@ -286,23 +289,26 @@ void hal_spi_disable(spi_config_t *spi)
 {
 	/* check parameters */
 	assert_param(IS_SSI_CHANNEL(spi->channel));
-	spi_hw[spi->channel].spix->SSIENR = 0;
+	__IO uint32_t* reg = &spi_hw[spi->channel].spix->SSIENR;
+	writel(reg, 0x00);
 }
 
 void hal_spi_enable(spi_config_t *spi)
 {
 	/* check parameters */
 	assert_param(IS_SSI_CHANNEL(spi->channel));
-	spi_hw[spi->channel].spix->SSIENR = 1;
+	__IO uint32_t* reg = &spi_hw[spi->channel].spix->SSIENR;
+	writel(reg, 0x01);
 }
 
 void hal_spi_reset(spi_config_t *spi)
 {
+	__IO uint32_t *reg = &spi_hw[spi->channel].spix->SSIENR;
 	/* check parameters */
 	assert_param(IS_SSI_CHANNEL(spi->channel));
-	spi_hw[spi->channel].spix->SSIENR = 0;
+	writel(reg, 0x00);
 	spi_delay(0xff);
-	spi_hw[spi->channel].spix->SSIENR = 1;
+	writel(reg, 0x01);
 }
 
 static spi_status_t hal_spi_receive_buf_dma(spi_config_t *spi, uint8_t *rx_buf,
@@ -403,6 +409,7 @@ static spi_status_t hal_spi_receive_buf_normal(spi_config_t *spi,
 	uint32_t rx_tmp = 0;
 	uint16_t index_rx = 0;
 	uint16_t buff_index = 0;
+	__IO uint32_t* reg = &spi_hw[spi->channel].spix->SSIENR;
 
 	/* Check parameters */
 	assert_param(IS_SSI_CHANNEL(spi->channel));
@@ -411,7 +418,7 @@ static spi_status_t hal_spi_receive_buf_normal(spi_config_t *spi,
 	if(spi_hw[spi->channel].spix->SSIENR == 0)
 	{
 		/* Enable SPI if which is disable */
-		spi_hw[spi->channel].spix->SSIENR = 1;
+		writel(reg, 0x01);
 	}
 
 	time_out = TIME_OUT_RX;
@@ -590,7 +597,7 @@ static spi_status_t hal_spi_transmit_buf_normal(spi_config_t *spi,
 	uint16_t index_tx = 0;
 	uint8_t count = 0;
 	uint32_t tx_tmp = 0;
-
+	__IO uint32_t *reg = &spi_hw[spi->channel].spix->DR[0];
 	/* Check parameters */
 	assert_param(IS_SSI_CHANNEL(spi->channel));
 	assert_param(!(tx_buf == NULL));
@@ -641,7 +648,7 @@ static spi_status_t hal_spi_transmit_buf_normal(spi_config_t *spi,
 				}
 			}
 			/* Move data need to send to FIFO */
-			spi_hw[spi->channel].spix->DR[0] = tx_tmp;
+			writel(reg, tx_tmp);
 		}
 
 		time_out = TIME_OUT_TX * SPI_FIFO_DEPTH;
@@ -857,7 +864,7 @@ static spi_status_t hal_spi_transceiver_normal(spi_config_t *spi,
 	uint32_t tx_tmp = 0, rx_tmp = 0, i = 0;
 	int idx_tx = 0, idx_rx = 0, count = 0;
 	int rx_fifo = 0;
-
+	__IO uint32_t *reg = &spi_hw[spi->channel].spix->SSIENR;
 	/* Check parameters */
 	assert_param(IS_SPI_DATA_SIZE(spi->data_size));
 	assert_param(IS_SPI_PHASE_MODE(spi->spi_mode));
@@ -874,7 +881,7 @@ static spi_status_t hal_spi_transceiver_normal(spi_config_t *spi,
 	buff->txbuf.counter = 0;
 
 	/* Enable SPI */
-	spi_hw[spi->channel].spix->SSIENR = 1;
+	writel(reg, 0x01);
 
 	while(buff_size != 0)
 	{
@@ -923,7 +930,8 @@ static spi_status_t hal_spi_transceiver_normal(spi_config_t *spi,
 				}
 			}
 			/* Move data need to send to FIFO */
-			spi_hw[spi->channel].spix->DR[0] = tx_tmp;
+			reg = &spi_hw[spi->channel].spix->DR[0];
+			writel(reg, tx_tmp);
 			buff->txbuf.counter = idx_tx;
 		}
 
@@ -941,7 +949,8 @@ static spi_status_t hal_spi_transceiver_normal(spi_config_t *spi,
 				time_out--;
 				if(time_out == 0)
 				{
-					spi_hw[spi->channel].spix->SSIENR = 0;
+					reg = &spi_hw[spi->channel].spix->SSIENR;
+					writel(reg, 0x00);
 					return SPI_ERROR;
 				}
 			}
@@ -975,7 +984,8 @@ static spi_status_t hal_spi_transceiver_normal(spi_config_t *spi,
 				default:
 				{
 					/* Disable SPI */
-					spi_hw[spi->channel].spix->SSIENR = 0;
+					reg = &spi_hw[spi->channel].spix->SSIENR;
+					writel(reg, 0x00);
 					return SPI_ERROR;
 				}
 			}
@@ -983,8 +993,9 @@ static spi_status_t hal_spi_transceiver_normal(spi_config_t *spi,
 			rx_fifo--;
 		}
 	}
+	reg = &spi_hw[spi->channel].spix->SSIENR;
 	/* Disable SPI */
-	spi_hw[spi->channel].spix->SSIENR = 0;
+	writel(reg, 0x00);
 	return SPI_OK;
 }
 
@@ -1013,6 +1024,7 @@ spi_status_t hal_spi_transceiver(spi_config_t *spi, spi_buffer_t *buff)
 void hal_spi_dma_init(spi_config_t *spi, dma_config_t *dma)
 {
 	uint32_t reg_tmp = 0;
+	__IO uint32_t *reg = &spi_hw[spi->channel].spix->DMATDLR;
 
 	/* Check parameters */
 	assert_param(IS_SPI_DATA_SIZE(spi->data_size));
@@ -1025,20 +1037,23 @@ void hal_spi_dma_init(spi_config_t *spi, dma_config_t *dma)
 	assert_param(IS_STATUS(dma->dma_transmit_enable));
 
 	/* Configure DMA transmit data level */
-	spi_hw[spi->channel].spix->DMATDLR = dma->dma_transmit_data_level;
+	writel(reg, dma->dma_transmit_data_level);
 	/* Configure DMA receive / receive data level */
-	spi_hw[spi->channel].spix->DMARDLR = dma->dma_transmit_data_level;
+	reg = &spi_hw[spi->channel].spix->DMARDLR;
+	writel(reg, dma->dma_transmit_data_level);
 	/* Enable/Disable transmit DMA enable bit */
 	reg_tmp = ((uint32_t)dma->dma_transmit_enable << 1) |
 			((uint32_t)dma->dma_receive_enable << 0);
+	reg = &spi_hw[spi->channel].spix->DMACR;
 
 	/* Initializing DMA controller */
-	spi_hw[spi->channel].spix->DMACR = reg_tmp;
+	writel(reg, reg_tmp);
 }
 
 void hal_spi_interrupt_init(spi_config_t *spi, spi_interrupt_init_t *interrupt)
 {
 	uint32_t reg_tmp = 0;
+	__IO uint32_t *reg = &spi_hw[spi->channel].spix->TXFTLR;
 
 	/* Check parameters */
 	assert_param(IS_SPI_DATA_SIZE(spi->data_size));
@@ -1063,8 +1078,7 @@ void hal_spi_interrupt_init(spi_config_t *spi, spi_interrupt_init_t *interrupt)
 	spi_hw[spi->channel].spix->TXFTLR = interrupt->tx_fifo_threshold;
 
 	/* Configure receive FIFO threshold */
-	spi_hw[spi->channel].spix->RXFTLR = interrupt->rx_fifo_threshold;
-
+	writel(reg, interrupt->rx_fifo_threshold);
 	/* Configure interrupts */
 	reg_tmp = (interrupt->multi_master_contention << SPI_INT_MSTI_OFFSET)	|
 				(interrupt->rx_fifo_full << SPI_INT_RXFI_OFFSET)			|
@@ -1109,8 +1123,9 @@ void hal_spi_interrupt_init(spi_config_t *spi, spi_interrupt_init_t *interrupt)
 			break;
 	}
 
+	reg = &spi_hw[spi->channel].spix->IMR;
 	/* Init interrupt */
-	spi_hw[spi->channel].spix->IMR = reg_tmp;
+	writel(reg, reg_tmp);
 }
 
 void hal_spi_interrupt_deinit(spi_config_t *spi)
@@ -1122,11 +1137,14 @@ void hal_spi_interrupt_deinit(spi_config_t *spi)
 	assert_param(IS_SPI_TYPE(spi->spi_type));
 	assert_param(IS_SSI_MODE(spi->ssi_mode));
 	assert_param(IS_SSI_CHANNEL(spi->channel));
+	__IO uint32_t *reg = &spi_hw[spi->channel].spix->IMR;
 
 	/* Disable all interrupt */
-	spi_hw[spi->channel].spix->IMR = 0;
-	spi_hw[spi->channel].spix->TXFTLR = 0;
-	spi_hw[spi->channel].spix->RXFTLR = 0;
+	writel(reg, 0x00);
+	reg = &spi_hw[spi->channel].spix->TXFTLR;
+	writel(reg, 0x00);
+	reg = &spi_hw[spi->channel].spix->RXFTLR;
+	writel(reg, 0x00);
 	spi_interrupt_enable[spi->channel] = DISABLE;
 	spi_interrupt[spi->channel].multi_master_handler = NULL;
 	spi_interrupt[spi->channel].rx_fifo_full_handler = NULL;
diff --git a/platform/asic/hal/src/hal_syncio.c b/platform/asic/hal/src/hal_syncio.c
index 38d31db..e5411cb 100644
--- a/platform/asic/hal/src/hal_syncio.c
+++ b/platform/asic/hal/src/hal_syncio.c
@@ -20,6 +20,7 @@
 #include "cortex_r4.h"
 #include "hal_vic.h"
 #include "stdbool.h"
+#include "std_type.h"
 
 /* Private typedef -----------------------------------------------------------*/
 
@@ -142,16 +143,23 @@ static void syncio_irq_handler(void);
  */
 void hal_syncio_init(hal_syncio_channel_t chid)
 {
+	__IO uint32_t* reg = &SYNCIO->SG[chid].CTRL;
 	/* Reset pulse generator setting as default */
-	SYNCIO->SG[chid].CTRL = (uint32_t)(SG_INF_EN | SG_TRIG_SW | SG_GEN_DIS);
-	SYNCIO->SG[chid].LAT1 = 0;
-	SYNCIO->SG[chid].LAT2 = 0;
-	SYNCIO->SG[chid].WIDTH1 = 0;
-	SYNCIO->SG[chid].WIDTH2 = 0;
+	writel(reg, (uint32_t)(SG_INF_EN | SG_TRIG_SW | SG_GEN_DIS));
+	reg = &SYNCIO->SG[chid].LAT1;
+	writel(reg, 0x00);
+	reg = &SYNCIO->SG[chid].LAT2;
+	writel(reg, 0x00);
+	reg = &SYNCIO->SG[chid].WIDTH1;
+	writel(reg, 0x00);
+	reg = &SYNCIO->SG[chid].WIDTH2;
+	writel(reg, 0x00);
 	/* Disable all interrupts */
-	SYNCIO->INT_MASK = 0;
+	reg = &SYNCIO->INT_MASK;
+	writel(reg, 0x00);
+	reg = &SYNCIO->INT_CLR;
 	/* Clear all interrupts */
-	SYNCIO->INT_CLR  = 0x0003FFFF;
+	writel(reg, 0x0003FFFF);
 }
 
 /**
@@ -167,18 +175,24 @@ void hal_syncio_config(hal_syncio_channel_t chid, hal_syncio_cfg_t *cfg_val)
 
 	/* Configure SG channel*/
 	SYNCIO->SG[chid].CTRL = cfg_val->trig_mode;
+	__IO uint32_t* reg = &SYNCIO->SG[chid].CTRL;
+
 	if(cfg_val->inf_mode)
 	{
-		SYNCIO->SG[chid].CTRL |= cfg_val->inf_mode;
+		writel(reg, SYNCIO->SG[chid].CTRL | cfg_val->inf_mode);
 	}
 	else
 	{
-		SYNCIO->SG[chid].CTRL |= REPEAT(cfg_val->repeat);
+		writel(reg, SYNCIO->SG[chid].CTRL | REPEAT(cfg_val->repeat));
 	}
-	SYNCIO->SG[chid].LAT1 = cfg_val->lat1;
-	SYNCIO->SG[chid].LAT2 = cfg_val->lat2;
-	SYNCIO->SG[chid].WIDTH1 = cfg_val->width1;
-	SYNCIO->SG[chid].WIDTH2 = cfg_val->width2;
+	reg = &SYNCIO->SG[chid].LAT1;
+	writel(reg, cfg_val->lat1);
+	reg = &SYNCIO->SG[chid].LAT2;
+	writel(reg, cfg_val->lat2);
+	reg = &SYNCIO->SG[chid].WIDTH1;
+	writel(reg, cfg_val->width1);
+	reg = &SYNCIO->SG[chid].WIDTH2;
+	writel(reg, cfg_val->width2);
 }
 
 /**
@@ -188,9 +202,9 @@ void hal_syncio_config(hal_syncio_channel_t chid, hal_syncio_cfg_t *cfg_val)
 void hal_syncio_enable(hal_syncio_channel_t chid)
 {
 	assert_param(IS_SYNCIO_CHANNEL(chid));
-
+	__IO uint32_t* reg = &SYNCIO->SG[chid].CTRL;
 	/* Enable Pulse Generator mode */
-	SYNCIO->SG[chid].CTRL |= SG_GEN_EN;
+	writel(reg, SYNCIO->SG[chid].CTRL | SG_GEN_EN);
 }
 
 /**
@@ -200,9 +214,9 @@ void hal_syncio_enable(hal_syncio_channel_t chid)
 void hal_syncio_disable(hal_syncio_channel_t chid)
 {
 	assert_param(IS_SYNCIO_CHANNEL(chid));
-
+	__IO uint32_t* reg = &SYNCIO->SG[chid].CTRL;
 	/* Disable Pulse Generator mode */
-	SYNCIO->SG[chid].CTRL &= ~SG_GEN_EN;
+	writel(reg, SYNCIO->SG[chid].CTRL & ~SG_GEN_EN);
 }
 
 /**
@@ -212,7 +226,8 @@ void hal_syncio_disable(hal_syncio_channel_t chid)
  */
 void hal_syncio_trigger(void)
 {
-	SYNCIO->GBL_CTRL = SG_SW_TRIGGER;
+	__IO uint32_t* reg = &SYNCIO->GBL_CTRL;
+	writel(reg, SG_SW_TRIGGER);
 }
 
 /**
@@ -227,11 +242,12 @@ void hal_syncio_enable_irq(hal_syncio_channel_t chid,
 	assert_param(IS_SYNCIO_INTR_MODES(irq_cfg->irq_modes));
 	assert_param(irq_cfg->callback_handler != NULL);
 
+	__IO uint32_t* reg = &SYNCIO->INT_MASK;
 	/* Store interrupt configuration */
 	syncio_irq_cfgs[chid].callback_handler = irq_cfg->callback_handler;
 	syncio_irq_cfgs[chid].irq_is_enabled = TRUE;
 	/* Enable interrupt */
-	SYNCIO->INT_MASK |= (irq_cfg->irq_modes << chid);
+	writel(reg, SYNCIO->INT_MASK | (irq_cfg->irq_modes << chid));
 	/* Register interrupt handler */
 	vic_register_irq(PPG_IRQn, syncio_irq_handler);
 }
@@ -245,13 +261,15 @@ void hal_syncio_disable_irq(hal_syncio_channel_t chid)
 	uint8_t		i;
 
 	assert_param(IS_SYNCIO_CHANNEL(chid));
-
+	__IO uint32_t* reg = &SYNCIO->INT_MASK;
 	/* Disable interrupt */
-	SYNCIO->INT_MASK &= ~((PULSE_DONE(chid) | REPEAT_DONE(chid) |
-							FALLING_EDGE(chid)));
+
+	writel(reg, SYNCIO->INT_MASK & ~((PULSE_DONE(chid) | REPEAT_DONE(chid) |
+							FALLING_EDGE(chid))));
+	reg = &SYNCIO->INT_CLR;
 	/* Clear interrupt pending */
-	SYNCIO->INT_CLR |= PULSE_DONE(chid) | REPEAT_DONE(chid) |
-							FALLING_EDGE(chid);
+	writel(reg, SYNCIO->INT_CLR | PULSE_DONE(chid) | REPEAT_DONE(chid) |
+							FALLING_EDGE(chid));
 	/* Reset interrupt configuration */
 	syncio_irq_cfgs[chid].callback_handler = NULL;
 	syncio_irq_cfgs[chid].irq_is_enabled = FALSE;
@@ -282,13 +300,14 @@ uint32_t hal_syncio_get_counter(hal_syncio_channel_t chid)
  */
 static void syncio_irq_handler(void)
 {
+	__IO uint32_t* reg = &SYNCIO->INT_CLR;
 	for (int i = 0; i < SG_CHANNEL_MAX; i++)
 	{
 		/* Check whether pulse done interrupt occurred */
 		if((SYNCIO->INT_STATE & PULSE_DONE(i)) != RESET)
 		{
 			/* Clear interrupt bit */
-			SYNCIO->INT_CLR |= PULSE_DONE(i);
+			writel(reg, SYNCIO->INT_CLR | PULSE_DONE(i));
 			/* Jump to handler */
 			syncio_irq_cfgs[i].callback_handler(i, SG_INTR_PULSE_DONE);
 		}
@@ -296,7 +315,7 @@ static void syncio_irq_handler(void)
 		if((SYNCIO->INT_STATE & REPEAT_DONE(i)) != RESET)
 		{
 			/* Clear interrupt bit */
-			SYNCIO->INT_CLR |= REPEAT_DONE(i);
+			writel(reg, SYNCIO->INT_CLR | REPEAT_DONE(i));
 			/* Jump to handler */
 			syncio_irq_cfgs[i].callback_handler(i, SG_INTR_REPEAT_DONE);
 		}
@@ -304,7 +323,7 @@ static void syncio_irq_handler(void)
 		if((SYNCIO->INT_STATE & FALLING_EDGE(i)) != RESET)
 		{
 			/* Clear interrupt bit */
-			SYNCIO->INT_CLR |= FALLING_EDGE(i);
+			writel(reg, SYNCIO->INT_CLR | FALLING_EDGE(i));
 			/* Jump to handler */
 			syncio_irq_cfgs[i].callback_handler(i, SG_INTR_FALLING_EDGE);
 		}
diff --git a/platform/asic/hal/src/hal_timer.c b/platform/asic/hal/src/hal_timer.c
index 46cc1dc..bf746f1 100755
--- a/platform/asic/hal/src/hal_timer.c
+++ b/platform/asic/hal/src/hal_timer.c
@@ -17,6 +17,7 @@
 #include "cortex_r4.h"
 #include "hal_vic.h"
 #include "hal_timer.h"
+#include "std_type.h"
 
 /* Private typedef -----------------------------------------------------------*/
 /*
@@ -145,15 +146,17 @@ hal_timer_return_t hal_timer_init(hal_timer_t *tim)
 	else
 	{
 		timer_regs *timer = timer_configs[tim->chid].handle;
+		__IO uint32_t* reg = &timer->TCR;
 
 		/* Disable the selected timer */
-		timer->TCR &= (~TIM_TCR_ENABLE);
+		writel(reg, timer->TCR & (~TIM_TCR_ENABLE));
 		/* Enable interrupt for the selected timer */
-		timer->TCR |= TIM_TCR_INT_MASK;
+		writel(reg, timer->TCR | TIM_TCR_INT_MASK);
 		/* Set interrupt handler */
 		timer_configs[tim->chid].callback_handler = tim->callback_handler;
 		/* Set the timer period */
-		timer->LCR = tim->period * (CLOCK_133MHZ / 1000000);
+		reg = &timer->LCR;
+		writel(reg, tim->period * (BOARD_PCLOCK / 1000000));
 		if(!intr_int_flag)
 		{
 			vic_register_irq(TIMER_IRQn, timer_irq_handler);
@@ -185,9 +188,9 @@ hal_timer_return_t hal_timer_update_period(hal_timer_t *tim)
 	else
 	{
 		timer_regs		*timer = timer_configs[tim->chid].handle;
-
+		__IO uint32_t* reg = &timer->LCR;
 		/* Set the timer period */
-		timer->LCR = tim->period * (CLOCK_133MHZ / 1000000);
+		writel(reg, tim->period * (BOARD_PCLOCK / 1000000));
 
 		ret = HAL_TIM_OK;
 	}
@@ -209,9 +212,9 @@ hal_timer_return_t hal_timer_start(hal_timer_channel_t chid)
 	else
 	{
 		timer_regs *timer = timer_configs[chid].handle;
-
+		__IO uint32_t* reg = &timer->TCR;
 		/* Enable the selected timer */
-		timer->TCR |= TIM_TCR_ENABLE;
+		writel(reg, timer->TCR | TIM_TCR_ENABLE);
 
 		ret = HAL_TIM_OK;
 	}
@@ -233,9 +236,9 @@ hal_timer_return_t hal_timer_stop(hal_timer_channel_t chid)
 	else
 	{
 		timer_regs *timer = timer_configs[chid].handle;
-
+		__IO uint32_t* reg = &timer->TCR;
 		/* Disable the selected timer */
-		timer->TCR &= (~TIM_TCR_ENABLE);
+		writel(reg, timer->TCR & (~TIM_TCR_ENABLE));
 
 		ret = HAL_TIM_OK;
 	}
@@ -259,8 +262,9 @@ unsigned int hal_timer_read_counter_reg(hal_timer_channel_t chid)
 void hal_timer_set_period(hal_timer_channel_t chid, unsigned int value)
 {
 	timer_regs *timer = timer_configs[chid].handle;
+	__IO uint32_t* reg = &timer->LCR;
 	/* Set the timer period */
-	timer->LCR = value;
+	writel(reg, value);
 }
 
 /*
diff --git a/platform/asic/hal/src/hal_vic.c b/platform/asic/hal/src/hal_vic.c
index 07ee60b..6b5bc31 100644
--- a/platform/asic/hal/src/hal_vic.c
+++ b/platform/asic/hal/src/hal_vic.c
@@ -17,6 +17,7 @@
 #include "hal_vic.h"
 #include "cortex_r4.h"
 #include "assert.h"
+#include "std_type.h"
 
 #ifdef OS
 #include "portmacro.h"
diff --git a/platform/asic/hal/src/hal_wdt.c b/platform/asic/hal/src/hal_wdt.c
index 24db3e2..21da2ba 100644
--- a/platform/asic/hal/src/hal_wdt.c
+++ b/platform/asic/hal/src/hal_wdt.c
@@ -17,7 +17,7 @@
 #include "cortex_r4.h"
 #include "hal_vic.h"
 #include "hal_wdt.h"
-
+#include "std_type.h"
 /* Private typedef -----------------------------------------------------------*/
 /**
  * @brief wdt_reg_t
@@ -60,6 +60,7 @@ wdt_status_t wdt_set_timeout(uint32_t period)
 	uint8_t top_value = 0;
 	uint8_t ret;
 	wdt_reg_t *wdtx = (wdt_reg_t *)WDT_BASE;
+	__IO uint32_t* reg = &wdtx->WDT_TORR;
 	for(int i = 0; i <= WDT_MAX_TOP; i++)
 	{
 		if(wdt_top_convert(i) >= period)
@@ -77,7 +78,7 @@ wdt_status_t wdt_set_timeout(uint32_t period)
 		ret = HAL_WDT_OK;
 	}
 	/* Update timeout period. */
-	wdtx->WDT_TORR = top_value & 0xF;
+	writel(reg, top_value & 0xF);
 	return ret;
 }
 
@@ -98,10 +99,11 @@ static void wdt_handler(void)
 void hal_wdt_init(uint32_t timeout, void(*clb_func)(void), uint8_t priority)
 {
 	wdt_reg_t *wdtx = (wdt_reg_t *)WDT_BASE;
+	__IO uint32_t* reg = &wdtx->WDT_CR;
 	/* Set Watchdog time out. */
 	wdt_set_timeout(timeout);
-	wdtx->WDT_CR	|=	WDT_RPL;
-	wdtx->WDT_CR	|=	WDT_EN_IRQ;
+	writel(reg, wdtx->WDT_CR	|	WDT_RPL);
+	writel(reg, wdtx->WDT_CR	|	WDT_EN_IRQ);
 	/* Initialize all modules without SCU module. */
 	writel(SCU_BASE + 0x48, ~((uint16_t)(0x00)));
 	writel(SCU_BASE + 0x4C, ~((uint32_t)(0x400000)));
@@ -119,19 +121,23 @@ void hal_wdt_init(uint32_t timeout, void(*clb_func)(void), uint8_t priority)
 void hal_wdt_start(void)
 {
 	wdt_reg_t *wdtx = (wdt_reg_t *)WDT_BASE;
-	wdtx->WDT_CR |= WDT_EN ;	/* Enable Watchdog */
+	__IO uint32_t* reg = &wdtx->WDT_CR;
+	/* Enable Watchdog */
+	writel(reg, wdtx->WDT_CR | WDT_EN);
 }
 
 void hal_wdt_stop(void)
 {
 	wdt_reg_t *wdtx = (wdt_reg_t *)WDT_BASE;
-	wdtx->WDT_CR &= ~WDT_EN;	/* Disable Watchdog */
+	__IO uint32_t* reg = &wdtx->WDT_CR;
+	writel(reg, wdtx->WDT_CR & ~WDT_EN);	/* Disable Watchdog */
 }
 
 void hal_wdt_kick_dog(void)
 {
 	wdt_reg_t *wdtx = (wdt_reg_t *)WDT_BASE;
+	__IO uint32_t* reg = &wdtx->WDT_CRR;
 	/* Restart the counter Watchdog. */
-	wdtx->WDT_CRR = 	WDT_RESTART;
+	writel(reg, WDT_RESTART);
 }
 /********** Portions COPYRIGHT 2016 Light.Co., Ltd.******* END OF FILE ********/
diff --git a/platform/common/os.h b/platform/common/os.h
index b48fb94..a733d9e 100644
--- a/platform/common/os.h
+++ b/platform/common/os.h
@@ -38,7 +38,11 @@ extern "C" {
 #include "event_groups.h"
 
 /* Exported define -----------------------------------------------------------*/
+#ifdef REG_DUMP_ENABLE
+#define TASK_NUM			7
+#else
 #define TASK_NUM			6
+#endif /* REG_DUMP_ENABLE */
 /**
  * IMPORTANT!!! This defined is used to select the task that interrupt signal
  * from other ASICs will notify.
diff --git a/platform/common/std_type.h b/platform/common/std_type.h
index fb60f17..300b8d2 100644
--- a/platform/common/std_type.h
+++ b/platform/common/std_type.h
@@ -129,9 +129,86 @@
 #define U16(p)	(uint16_t)(*(uint16_t *)&p)		/* Casting buffer to uint16_t */
 #define U32(p)	(uint32_t)(*(uint32_t *)&p)		/* Casting buffer to uint32_t */
 
-#define writel(addr, value)	*(volatile unsigned int  *)(addr) = value
 #define readl(addr)			*(volatile unsigned int  *)(addr)
 
+#ifdef REG_DUMP_ENABLE
+	#define DUMP_BUFFER_MAX 512
+	typedef struct
+	{
+		unsigned int address;
+		unsigned int write;
+		unsigned int read;
+	}regs_fail_info_t;
+	// Need declare these variables when use register dump
+	extern regs_fail_info_t  regs_dump[DUMP_BUFFER_MAX];
+	extern regs_fail_info_t* preg_dump;
+	#define writel(addr, value)	                              \
+		*(volatile unsigned int  *)(addr) = (value);          \
+		if (preg_dump < &regs_dump[DUMP_BUFFER_MAX - 1])      \
+		{                                                     \
+			__asm ("NOP");                                    \
+			__asm ("NOP");                                    \
+			__asm ("NOP");                                    \
+			__asm ("NOP");                                    \
+			if (readl(addr) != (value))                       \
+			{                                                 \
+				preg_dump->address  = (unsigned int)(addr);   \
+				preg_dump->write    = (value);                \
+				preg_dump->read     = readl(addr);            \
+				preg_dump++;                                  \
+			}                                                 \
+		}
+
+	#ifdef P2
+	/* This macro can be used only after initialized UART */
+	#define WRITE_REGS_CHECK() 	                                                       \
+	if (preg_dump == regs_dump)                                                        \
+	{																	               \
+		slogf(SLOG_ID_LIGHT_SYSTEM, SLOG_INFO, "REG DUMP OK");                         \
+	}                                                                                  \
+	else                                                                               \
+	{                                                                                  \
+		while (preg_dump != regs_dump)                                                 \
+		{								                                 		       \
+			preg_dump--;      			                                 		       \
+			slogf(SLOG_ID_LIGHT_SYSTEM, SLOG_ERROR,                                    \
+					"REG_FAILED: addr = 0x%08u, write = 0x%08u, read = 0x%08u",        \
+					regs_dump->address, regs_dump->write, regs_dump->read);            \
+		}                                                                              \
+		slogf(SLOG_ID_LIGHT_SYSTEM, SLOG_ERROR, "REG DUMP FAILED");                    \
+	}
+
+	#elif defined QC_PLATFORM /* For QC HAL test only */
+	/* This macro can be used only after initialized UART */
+	#define WRITE_REGS_CHECK() 	                                                       \
+	if (preg_dump == regs_dump)                                                        \
+	{																	               \
+		log_printf("REG DUMP OK\r\n");                                                 \
+	}                                                                                  \
+	else                                                                               \
+	{                                                                                  \
+		while (preg_dump != regs_dump)                                                 \
+		{								                                 		       \
+			preg_dump--;      			                                 		       \
+			log_printf("REG_FAILED: addr = 0x%08u, write = 0x%08u, read = 0x%08u\r\n", \
+					regs_dump->address, regs_dump->write, regs_dump->read);            \
+		}                                                                              \
+		log_printf("REG DUMP FAILED\r\n");                                             \
+	}
+
+	#endif /* P2 && QC_PLATFORM */
+
+/**
+ * Reset all memory of dump information
+ * This macro should be called after calling WRITE_REGS_CHECK()
+ *
+ **/
+#define REGS_DUMP_RESET()                                                \
+	memset(regs_dump, 0x00, DUMP_BUFFER_MAX * sizeof(regs_fail_info_t)); \
+	preg_dump = regs_dump;
+#else
+	#define writel(addr, value)	*(volatile unsigned int  *)(addr) = value;
+#endif /* REG_DUMP_ENABLE */
 /* Exported typedef  ---------------------------------------------------------*/
 
 #endif /* __STD_TYPES_H__ */
diff --git a/platform/common/task_list.c b/platform/common/task_list.c
index cbc2a58..9b15221 100644
--- a/platform/common/task_list.c
+++ b/platform/common/task_list.c
@@ -23,6 +23,9 @@
 #include "sections.h"
 #include "ina231.h"
 
+#ifdef REG_DUMP_ENABLE
+#include "regs_dump.h"
+#endif
 /* Exported variables---------------------------------------------------------*/
 /* Exported functions---------------------------------------------------------*/
 /* task handler */
@@ -77,7 +80,17 @@ const task_configure_t task_list[TASK_NUM] =
 		.prio =			__TASK_PRIO_HIGHEST - 14,
 		.stacksize =	__TASK_STACK_SIZE_128,
 		.time_sleep =	1,
+	},
+	#ifdef REG_DUMP_ENABLE
+	/* task_regs_check */
+	{
+		.task =			task_regs_check,
+		.name =			"regscheck",
+		.prio =			__TASK_PRIO_HIGHEST - 14,
+		.stacksize =	__TASK_STACK_SIZE_128,
+		.time_sleep =	1,
 	}
+	#endif
 	/**
 	 * @brief ADD MORE TASK HERE <<<<<<<<<<<<<<<<<<<
 	 */
